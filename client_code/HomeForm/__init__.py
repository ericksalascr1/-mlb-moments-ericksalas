import anvil.tables as tables
import anvil.tables.query as q
from anvil.tables import app_tables
 import anvil.http<html lang="en" class="js anvil-runner runner sizes customelements history pointerevents postmessage postmessage-structuredclones webgl websockets cssanimations csscolumns csscolumns-width csscolumns-span csscolumns-fill csscolumns-gap csscolumns-rule csscolumns-rulecolor csscolumns-rulestyle csscolumns-rulewidth csscolumns-breakbefore csscolumns-breakafter csscolumns-breakinside flexbox picture srcset webworkers" data-darkreader-scheme="dark" data-darkreader-proxy-injected="true"><head><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, img.Wirisformula {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #181a1b;
   --darkreader-neutral-text: #e8e6e3;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: dark !important;
}
html, body {
    background-color: #181a1b;
}
html, body {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
mark {
    color: #e8e6e3;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
}</style>
  <base href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="expires" content="0">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="referrer" content="never"> <!-- Yes, this is "legacy", but Safari and Edge don't support 'no-referrer' yet -->

  <meta name="og:title" content="MLB Moments">
  <meta name="title" content="MLB Moments">
  <meta name="og:type" content="website">
  <meta name="og:url" content="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R">
  <meta name="og:image" content="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/theme/images.png">
  <!--<xmeta name="og:image:width" content="400">-->
  <!--<xmeta name="og:image:height" content="400">-->
  <!--<xmeta name="og:site_name" content="Anvil">-->
  <meta name="og:description" content="Provide real-time updates and in-game predictions during live broadcasts. Explore Gamification">
  <meta name="description" content="Provide real-time updates and in-game predictions during live broadcasts. Explore Gamification">


  <title>MLB Moments</title>

  <!-- <link rel="stylesheet" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/css/bootstrap.css?sha=adc8ee1e2b08f322404a" crossorigin/> -->
  <!-- <link rel="stylesheet" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/css/bootstrap-theme.min.css?sha=f2e1cc227d6bbb4192e4" crossorigin/> -->
  <style>
  .anvil-spinner{width:70px;height:70px}
  .anvil-spinner{color:#2196F3}
  </style><style class="darkreader darkreader--sync" media="screen"></style>
  <link rel="stylesheet" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/css/bootstrap.css?sha=c72a0381af84afb75234" crossorigin=""><style class="darkreader darkreader--sync" media="screen"></style>
<link rel="stylesheet" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/css/bootstrap-theme.min.css?sha=42cf18f709a52a7f4a0a" crossorigin=""><style class="darkreader darkreader--sync" media="screen"></style>
<link rel="stylesheet" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/node_modules/animate.css/animate.min.css?sha=b99997f8705218b0610b" crossorigin=""><style class="darkreader darkreader--sync" media="screen"></style>
  <link rel="stylesheet" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/dist/runner.min.css?sha=adc877189c16a1666010" crossorigin=""><style class="darkreader darkreader--sync" media="screen"></style>
  <link rel="stylesheet" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/dist/runner-v3.min.css?sha=e09f43ffdf48fb9e08ca" crossorigin=""><style class="darkreader darkreader--sync" media="screen"></style>
  <link rel="stylesheet" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/css/daterangepicker.min.css?sha=60f595b9eaccc23f5b95" crossorigin=""><style class="darkreader darkreader--sync" media="screen"></style>
  <!-- <link rel="stylesheet" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/node_modules/animate.css/animate.min.css?sha=8fe3fa119255adb5e0c1" crossorigin/> -->

  <link rel="stylesheet" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/css/font-awesome.min.css?sha=b1d7cc003eb49d03092a" crossorigin=""><style class="darkreader darkreader--sync" media="screen"></style>

  <!-- Favicon things -->
  <link rel="icon" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/theme/images.png">
  <link rel="manifest" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/manifest.json?buildTime=0">
  <link rel="apple-touch-icon" href="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/theme/images.png">
  <meta name="apple-mobile-web-app-title" content="MLB Moments">
  <meta name="application-name" content="MLB Moments">
  <meta name="msapplication-TileColor" content="#2b5797">
  <meta name="msapplication-TileImage" content="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/theme/images.png">
  <meta name="theme-color" content="#0a6ab6">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">

  <style></style><style class="darkreader darkreader--sync" media="screen"></style>
  <style>:root {
--anvil-color-Primary-700-8e45:#1976D2;
--anvil-color-Black-df88:#000000;
--anvil-color-Secondary-500-5364:#FF9800;
--anvil-color-Gray-900-6590:#212121;
--anvil-color-Gray-100-ebfa:#F5F5F5;
--anvil-color-Gray-300-9dda:#E0E0E0;
--anvil-color-Gray-800-54c7:#424242;
--anvil-color-White-beae:#FFFFFF;
--anvil-color-Gray-200-9626:#EEEEEE;
--anvil-color-Gray-600-f264:#757575;
--anvil-color-Primary-500-268b:#2196F3;
--anvil-color-Secondary-700-4270:#F57C00;
--anvil-color-Gray-50-1a61:#FAFAFA;
}</style><style class="darkreader darkreader--sync" media="screen"></style>
  
<style>
/**
 This CSS implements the Material Design look and feel for Anvil apps.
 **/

/* Stop panel-cols cutting off drop shadows */
.anvil-panel-col {
  padding-bottom: 10px;
  margin-bottom: -10px;
}

.content > .placeholder {
  margin: 16px;
  color: #888;
  font-size: 18px;
  outline: 1px dotted;
  padding: 16px;
  text-align: center;
}

/* Put things on a 4px grid (none of this 7px nonsense) */
.has-text .anvil-component-icon.left-icon { margin-right: 8px; }
.has-text .anvil-component-icon.right-icon { margin-left: 8px; }

a>.anvil-component-icon.left_edge-icon,
a>.anvil-component-icon.right_edge-icon,
.anvil-label>.anvil-component-icon.left_edge-icon,
.anvil-label>.anvil-component-icon.right_edge-icon {
  padding-top: 8px;
  padding-bottom: 8px;
}
.anvil-label>.label-text, a>.link-text {
  padding-top: 8px;
  padding-bottom: 8px;
}
.file-loader>label {
    padding: 8px;
}
.checkbox label, .radio label {
    padding-top: 8px; padding-right: 8px; padding-bottom: 8px;
}
.anvil-spacing-above-none { margin-top: 0px; }
.anvil-spacing-above-small { margin-top: 4px; }
.anvil-spacing-above-medium { margin-top: 8px; }
.anvil-spacing-above-large { margin-top: 16px; }
.anvil-spacing-below-none { margin-bottom: 0px; }
.anvil-spacing-below-small { margin-bottom: 4px; }
.anvil-spacing-below-medium { margin-bottom: 8px; }
.anvil-spacing-below-large { margin-bottom: 16px; }


.col-padding.col-padding-tiny { padding: 0 2px; }
.column-panel.col-padding-tiny > .anvil-panel-section > .anvil-panel-section-container > .anvil-panel-section-gutter { margin: 0 -2px; }

.col-padding.col-padding-small { padding: 0 4px; }
.column-panel.col-padding-small > .anvil-panel-section > .anvil-panel-section-container > .anvil-panel-section-gutter { margin: 0 -4px; }

.col-padding.col-padding-medium { padding: 0 8px; }
.column-panel.col-padding-medium > .anvil-panel-section > .anvil-panel-section-container > .anvil-panel-section-gutter { margin: 0 -8px; }

.col-padding.col-padding-large { padding: 0 12px; }
.column-panel.col-padding-large > .anvil-panel-section > .anvil-panel-section-container > .anvil-panel-section-gutter { margin: 0 -12px; }

.col-padding.col-padding-huge { padding: 0 20px; }
.column-panel.col-padding-huge > .anvil-panel-section > .anvil-panel-section-container > .anvil-panel-section-gutter { margin: 0 -20px; }

.flow-panel.flow-spacing-tiny > .flow-panel-gutter { margin: 0 -2px; }
.flow-panel.flow-spacing-tiny > .flow-panel-gutter > .flow-panel-item { margin: 0 2px; }

.flow-panel.flow-spacing-small > .flow-panel-gutter { margin: 0 -4px; }
.flow-panel.flow-spacing-small > .flow-panel-gutter > .flow-panel-item { margin: 0 4px; }

.flow-panel.flow-spacing-medium > .flow-panel-gutter { margin: 0 -8px; }
.flow-panel.flow-spacing-medium > .flow-panel-gutter > .flow-panel-item { margin: 0 8px; }

.flow-panel.flow-spacing-large > .flow-panel-gutter { margin: 0 -12px; }
.flow-panel.flow-spacing-large > .flow-panel-gutter > .flow-panel-item { margin: 0 12px; }

.flow-panel.flow-spacing-huge > .flow-panel-gutter { margin: 0 -20px; }
.flow-panel.flow-spacing-huge > .flow-panel-gutter > .flow-panel-item { margin: 0 20px; }


/* Typography */
body {
  font-family: Roboto, Noto, Arial, sans-serif;
  font-size: 14px;
  line-height: 1.4286;
  background-color: #fafafa;
}

a, a:focus {
  text-decoration: none;
  color: var(--anvil-color-Primary-700-8e45);
}

a:hover, a:active {
  color: var(--anvil-color-Primary-500-268b);
}

.anvil-label {
/*  font-size: 16px;*/
}

.anvil-role-subheading {
  font-size: 16px;
  line-height: 24dp;
}

.anvil-role-headline {
  font-size: 24px;
  line-height: 32px;
}

.anvil-role-input-prompt {
  font-size: 16px;
  line-height: 1.5;
}

.anvil-role-display-4 {
  font-size: 112px;
  font-weight: light;
}

.anvil-role-text {
  font-size: 14px;
}
.anvil-role-text > .label-text, .anvil-role-text .link-text {
  padding-top: 0;
  padding-bottom: 0;
}

/* Page structure: App bar with optional left nav */
.structure {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  height: 0; /* To make flex-grow work in IE */
}

/* However, this breaks the designer's height measurement. IE isn't supported for the designer, so set it back. */
.designer .structure {
  height: initial;
}

.app-bar {
  flex: 0 0;
  flex-basis: auto;
  flex-basis: content;
}

.nav-holder {
  flex-grow: 1;
  overflow-y: auto;
}

/* Mobile and desktop margins for content */
.content > * > .anvil-container {
  padding: 8px;
}

@media(min-width:991px) {
  .content > * > .anvil-container {
    padding: 16px 24px;
  }
}

.content .anvil-measure-this {
  padding-bottom: 1px; /* Prevent margin collapse messing up embedding */
}

/* Allow overflows to show drop shadows in ColumnPanels
   This can create unwanted scrollbars; we compensate for this at the top level with .nav-holder .content {overflow-x: hidden;}
*/
.anvil-container-overflow {
  overflow-x: visible;
  overflow-y: visible;
}


/* Desktop: Nav bar pinned */

.nav-holder {
  display: flex;
  flex-direction: row;
}

.nav-holder .left-nav {
  position: relative;
  flex-shrink: 0;
  min-width: 160px;
  max-width: 400px;
}

.nav-shield {
  display: none;
}

/* Mobile: Nav bar is a modal overlay */

@media(max-width:998px) {
  html:not(.designer) .nav-holder {
    display: block;
  }
  html:not(.designer) .nav-holder .left-nav {
    position: fixed;
    top: 0;
    bottom: 0;
    width: calc(100% - 56px);
    max-width: 360px;
    z-index: 3;
    border-right: none;
  /* 16dp */ box-shadow: 0 16px 24px 2px rgba(0, 0, 0, 0.14), 0 6px 30px 5px rgba(0, 0, 0, 0.12), 0 8px 10px -5px rgba(0, 0, 0, 0.2);

    display: none;
    transition: right 0.5s;
  }
  
  html:not(.designer) .nav-holder .left-nav.shown {
    display: block;
  }
  .nav-shield.shown {
    display: block;
    position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 2;
    background-color: rgba(0,0,0,0.2);
  }
 }

.nav-holder .left-nav, .left-nav-placeholder {
  display: flex;
  flex-direction: column;
  background: white;
  border-right: 1px solid #e0e0e0;
  font-size: 14px;
  font-weight: 500;
  color: rgba(0,0,0,0.87);
  overflow-x: hidden;
  overflow-y: auto;
}

.left-nav-placeholder {
  display: block;
  padding: 8px;
  line-height: 1;
  width: 58px;
}
.left-nav-placeholder .prompt {
  display: inline-block;
  white-space: nowrap;
  transform: translate(-50%,0) rotate(-90deg) translate(-50%,0) translate(15px,16px);
  padding: 16px 16px;
  color: #888;
  outline: 1px dotted #888;
  visibility: hidden;
}
.anvil-highlight .left-nav-placeholder .prompt {
  visibility: visible;
}

.left-nav > .column-panel {
  padding: 24px 0;
}
.left-nav > .column-panel > .anvil-panel-section > .anvil-panel-section-container:not(.full-width-row) {
  margin: 0 16px;
  width: initial;
  max-width: initial;
  overflow-x: visible;
}
.left-nav > .column-panel > .anvil-panel-section:first-child > .anvil-panel-section-container.full-width-row {
  margin-top: -24px;
}
.left-nav > .column-panel > .anvil-panel-section > .anvil-panel-section-container > .anvil-panel-section-gutter > .anvil-panel-row > .anvil-panel-col {
  overflow-x: visible;
}

/* Make all the sidebar icons look nice */

.left-nav .anvil-component-icon {
  font-size: 160%;
}

.left-nav .anvil-component-icon.left-icon {
  width: 0;
  margin-right: 56px;
  position: relative;
  top: 0.15em;  
}

.left-nav .anvil-component-icon.left_edge-icon, .left-nav .anvil-component-icon.right_edge-icon {
  left: 16px;
  padding-top: 2px;
  width: 0;
}

.left-nav .anvil-component-icon.right_edge-icon {
  left: initial;
  right: 16px;
  top: 0;
  padding-top: 2px;
}

/* Sidebar links (and labels with edge icons) go +16px wider
   (Top-level columns in ColumnPanels get overflow-x visible [see above]to enable this)
*/

.left-nav a, .left-nav .anvil-label.left_edge-icon, .left-nav .anvil-label.right_edge-icon {
  color: rgba(0,0,0,0.87);
  margin: 0 -16px;
  padding: 4px 16px;
}

.left-nav .anvil-component.left_edge-icon {
  padding-left: 72px;
}

.left-nav a:hover, .left-nav .anvil-role-selected {
  color: var(--anvil-color-Primary-700-8e45);
  background-color: rgba(0,0,0,.08);
}

.designer .nav-holder .left-nav {
  min-width: 56px;
}

.designer .nav-holder .left-nav > .anvil-component {
  min-width: 160px;
}

.nav-holder .left-nav > .anvil-component {
  margin-top: 0;
  margin-bottom: 0;
}

.nav-holder .content {
  flex: 1;
  overflow-x: hidden;
}

/* Components: App Bar */
.app-bar {
  min-height: 56px;
  line-height: 40px;
  padding: 0 16px 0 72px;

  font-size: 20px;
  font-weight: 500;
  color: white;
  background-color: var(--anvil-color-Primary-500-268b);
  
  z-index: 1;
  /* 4dp */ box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12), 0 2px 4px -1px rgba(0, 0, 0, 0.2);  
}

.app-bar .anvil-component {
  margin-top: 0;
  margin-bottom: 0;
}

.app-bar > .sidebar-toggle { display:block; float:left;  margin-left: -61px; }
.app-bar > .top-left-btn { float: left; margin-left: -60px; margin-right: -40px; }
.app-bar > .title { float: left; }
.app-bar > .title > .placeholder { outline: 1px dotted; padding-left: 16px; padding-right: 16px; margin: 8px 8px 0; display:none; }
.app-bar > .app-bar-nav { float: right; font-weight: normal; }
.app-bar > .app-bar-nav .placeholder { margin-top: 8px; padding: 0 8px; }
.anvil-highlight .app-bar > .app-bar-nav .placeholder { outline: 1px dotted #ccc; }
.anvil-highlight .app-bar > .title > .placeholder { display:block; }

.app-bar a, .app-bar .anvil-component {
  display: block;
  color: white;
  line-height: 30px;
  min-width: 30px;
  min-height: 30px;
  margin: 5px 4px 0;
}

.app-bar .title .anvil-component {
  margin-left: 0;
}

.app-bar input.anvil-component, .app-bar .anvil-component input {
  line-height: 30px;
  color: white;
}

.app-bar select.form-control {
  height: 43px; /* 30px line height + 12px padding + 1px border */
}

.app-bar .anvil-component-icon-present .anvil-component-icon, .app-bar .sidebar-toggle .fa {
  width: 30px;
  text-align: center;
}

/* Don't put spacing on the top-level container (eg FlowPanel) */
.app-bar-nav > .anvil-container {
  margin: 0;
  padding: 0;
  min-height: 56px;
}

.anvil-highlight .app-bar-nav > .anvil-container:not(.has-components):not(a) {
  outline: 1px dotted #fff;
  margin-top: 8px;
  min-height: 40px;
  padding: 5px 8px;
}

.anvil-highlight .app-bar-nav > .anvil-container:not(.has-components):not(a)::after {  
  content: "Drop Links here"
}

/* Rejig margin vs padding to give links the halo */
.app-bar a, .app-bar a.anvil-component {
  padding: 5px;
  margin: 8px 0 0;
  border-radius: 20px;
}

.app-bar a .link-text {
  padding: 0 4px;
}
.app-bar a.has-text .anvil-component-icon.left {
  margin-right: 4px;
}
.app-bar a.has-text .anvil-component-icon.right {
  margin-left: 4px;
}

.app-bar a:hover, .app-bar a:active {
  color: #eee; text-decoration: none;
  background-color: var(--anvil-color-Primary-700-8e45);
}


/* Component: Dialog (alert), Notification */
.modal-content, body>div[data-notify="container"] {
  border-radius: 2px;
  /* 24dp */ box-shadow: 0 9px 46px 8px rgba(0, 0, 0, 0.14), 0 11px 15px -7px rgba(0, 0, 0, 0.12), 0 24px 38px 3px rgba(0, 0, 0, 0.2)
    !important;
}

.modal-header {
  padding: 24px 24px 0px;
  font-size: 24px;
  line-height: 32px;
  border: 0;
}

.modal-body {
  padding: 20px 24px 24px;
  font-size: 16px;
  color: #747474;
}

.modal-footer {
  padding: 8px 8px 8px 24px;
  border: 0;
}

.modal-footer .btn {
  background-color: transparent;
  color: var(--anvil-color-Primary-500-268b);
}
.modal-footer .btn, .modal-footer .btn:focus, .modal-footer .btn:active {
  box-shadow: none;
  top: 0;
}

/* Notifications */
body>div[data-notify="container"] {
  background: white;
  border: none;
  padding: 24px;
}

body>div[data-notify="container"]>span[data-notify="title"] {
  display: block;
  font-size: 18px;
  font-weight: 500;
  color: #333333;
}

body>div[data-notify="container"]>span[data-notify="message"] {
  display: block;
  padding: 20px 0 0;
  font-size: 16px;
  color: #747474;  
}

body>div[data-notify="container"].alert-success{
  background-color: #d4edda;
}

body>div[data-notify="container"].alert-success>span[data-notify="title"]{
  color: #155724;
}

body>div[data-notify="container"].alert-danger{
  background-color: #f8d7da;
}

body>div[data-notify="container"].alert-danger>span[data-notify="title"]{
  color: #721c24;
}

body>div[data-notify="container"].alert-warning{
  background-color: #fff3cd;
}

body>div[data-notify="container"].alert-warning>span[data-notify="title"]{
  color: #856404;
}


/* Component: Button */

.btn, .btn-default, .file-loader>label {
  border-radius: 2px;
  font-size: 14px;
  font-weight: 500;
  padding: 8px 16px;
  min-height: calc(16px + 1.42857143em);
  text-transform: uppercase;

  border: 0;
  background-image: none;
  background-color: transparent;
  color: var(--anvil-color-Primary-500-268b);
  text-shadow: none;
  box-shadow: none;
  -webkit-box-shadow: none;
  
  position: relative;
}

.btn:hover, .btn:focus, .file-loader>label:hover {
  background-color: rgba(153,153,153,0.2);
  background-image: none;
  outline: none;
  color: var(--anvil-color-Primary-500-268b);
}

.btn:active, .btn:active:focus {
  background-color: rgba(153,153,153,0.4);
  background-image: none;
  outline: none;
  box-shadow: none;
  color: var(--anvil-color-Primary-500-268b);
}

.btn[disabled] { color: rgba(0, 0, 0, .25); }
.anvil-role-raised > .btn[disabled], .anvil-role-primary-color > .btn[disabled], .anvil-role-secondary-color > .btn[disabled] {
  background-color: rgba(0,0,0,0.12) !important;
  color: rgba(0,0,0,0.25) !important;
  box-shadow: none !important;
}

.anvil-role-raised > .btn, .anvil-role-primary-color > .btn, .anvil-role-secondary-color > .btn, .anvil-role-raised.file-loader>label, .anvil-role-primary-color.file-loader>label, .anvil-role-secondary-color.file-loader>label,
.btn-primary, .btn-success, .btn-info, .btn-warning, .btn-danger
{
  /* 2dp */  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
}

.anvil-role-raised > .btn:active, .anvil-role-primary-color > .btn:active, .anvil-role-secondary-color > .btn:active, .btn-primary:active,
.btn-primary:active, .btn-success:active, .btn-info:active, .btn-warning:active, .btn-danger:active {
  /* 8dp */ box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.2);  
  top: -1px;
}

.anvil-role-primary-color > .btn, .btn-primary, .anvil-role-primary-color.file-loader>label {
  color: white;
  background-color: var(--anvil-color-Primary-500-268b);
}

.anvil-role-secondary-color > .btn, .anvil-role-secondary-color.file-loader>label {
  color: white;
  background-color: var(--anvil-color-Secondary-500-5364);
}

.btn-success, .btn-info, .btn-warning, .btn-danger {
  color: white;
}

.anvil-role-primary-color > .btn:hover, .anvil-role-primary-color > .btn:active, .anvil-role-primary-color > .btn:focus,
.btn-primary:hover, .btn-primary:active, .btn-primary:focus {
  color: white;
  background-color: var(--anvil-color-Primary-700-8e45);
}

.anvil-role-secondary-color > .btn:hover, .anvil-role-secondary-color > .btn:active, .anvil-role-secondary-color > .btn:focus {
  color: white;
  background-color: var(--anvil-color-Secondary-700-4270);
}

/* Component: Card */

.anvil-role-card {
  overflow: hidden;
  border-radius: 2px;
  background-color: white;
  padding: 8px 12px;
  /* 2dp */  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
}

/* full_width_row sections go full bleed */
.column-panel.anvil-role-card > .anvil-panel-section > .anvil-panel-section-container.full-width-row {
  margin-left: -12px;
  margin-right: -12px;
  width: initial;
  max-width: initial;
}

/* If the first row of a card is a full_width_row, it goes to the top */
.column-panel.anvil-role-card > .anvil-panel-section:first-child > .anvil-panel-section-container.full-width-row {
  margin-top: -8px;
}
.column-panel.anvil-role-card > .anvil-panel-section:last-child > .anvil-panel-section-container.full-width-row {
  margin-bottom: -8px;
}



/* Component: TextBox + TextArea */

input.anvil-component, textarea.anvil-component, .anvil-component select, .anvil-datepicker input {
  font-size: 16px;
  line-height: 1.5;
  border-radius: 0;
  background-color: transparent;
  color: rgba(0,0,0,0.87);
  
  box-shadow: none;
}

.anvil-dropdown {
  font-size: 16px;
}
.anvil-component select {
  font-size: inherit;
}

input.anvil-component, .anvil-component select, .anvil-datepicker input {
  padding: 8px 0 4px;
  border: 0;
  border-bottom: 1px solid rgba(0,0,0,0.42);

  transition: border-bottom 0.2s, padding-bottom 0.2s;
  -moz-transition: none; /* Firefox is jumpy, so disable transitions */
}

textarea.anvil-component {
  padding: 4px 8px;
  border: 1px solid rgba(0,0,0,0.42);
  border-radius: 2px;
  transition: border 0.2s, padding 0.2s;
  -moz-transition: none; /* Firefox is jumpy, so disable transitions */
}

.anvil-dropdown select.form-control {
  
  -webkit-appearance: none;
  -moz-appearance: none;
  padding: 8px 2em 4px 0;
  
  /* ew ew ew - select elements are weird and don't obey line-height, so we just
     set the height explicitly. Ugh. */
  height: calc(1.5em + 13px); /* 8px + 4px padding + 1px border = 13px */
}

.anvil-dropdown {
  position: relative;
}
/* Select arrow styling */
.anvil-dropdown form:before {
    content: "\25BC";
    position: absolute;
    right: 0;
    font-size: 80%;
    line-height: calc(1.8em + 8px);
    color: #555;
    pointer-events:none;
    padding: 4px 4px;
}

.anvil-component select, .anvil-datepicker input { margin-bottom: 4px; }
input.anvil-component.anvil-spacing-below-none { margin-bottom: 4px; }
input.anvil-component.anvil-spacing-below-small { margin-bottom: 8px; }
input.anvil-component.anvil-spacing-below-medium { margin-bottom: 12px; }
input.anvil-component.anvil-spacing-below-large { margin-bottom: 20px; }

input.anvil-component::-webkit-input-placeholder, textarea.anvil-component::-webkit-input-placeholder {
  color: rgba(0,0,0,0.54);
}
input.anvil-component::-moz-placeholder, textarea.anvil-component::-moz-placeholder {
  color: rgba(0,0,0,0.54);
}
input.anvil-component::placeholder, textarea.anvil-component::placeholder  {
  color: rgba(0,0,0,0.54);
}

.app-bar input.anvil-component::-webkit-input-placeholder, .app-bar textarea.anvil-component::-webkit-input-placeholder {
  color: rgba(255,255,255,0.8);
}
.app-bar input.anvil-component::-moz-placeholder, .app-bar textarea.anvil-component::-moz-placeholder {
  color: rgba(255,255,255,0.8);
}
.app-bar input.anvil-component::placeholder, .app-bar textarea.anvil-component::placeholder  {
  color: rgba(255,255,255,0.8);
}

input.anvil-component:hover, .anvil-component select:hover, .anvil-datepicker input:hover {
  border-bottom: 2px solid rgba(0,0,0,.87);
  padding-bottom: 3px;
}

input.anvil-component:focus, .anvil-component select:focus, .anvil-datepicker input:focus {
  border-bottom: 2px solid var(--anvil-color-Primary-700-8e45);
  padding-bottom: 3px;
  box-shadow: none;
}

input.anvil-component[disabled], .anvil-component select[disabled], .anvil-datepicker input[disabled] {
  border-bottom: 1px dashed #888;
  padding-bottom: 4px;
  background-color: transparent;
}

textarea.anvil-component:hover {
  border: 2px solid rgba(0,0,0,0.87);
  padding: 3px 7px;
}

textarea.anvil-component:focus {
  border: 2px solid var(--anvil-color-Primary-700-8e45);
  padding: 3px 7px;
  box-shadow: none;
}

textarea.anvil-component[disabled] {
  border: 1px dashed #888;
  padding: 4px 8px;
  background-color: transparent;
}

.daterangepicker td.active {
  background-color: var(--anvil-color-Primary-500-268b);
}

.daterangepicker td.active:hover {
  background-color: var(--anvil-color-Primary-700-8e45);
}

.daterangepicker .btn-success {
  color: var(--anvil-color-Primary-500-268b);
}

/* Component: CheckBox, RadioButton */
/* Ugh. These are definitely TODO right now. */

.checkbox, .radio {
  font-size: 16px;
}

/* Shadow values taken from 
https://stackoverflow.com/questions/30533055/calculating-shadow-values-for-all-material-design-elevations
*/

/* Display information about this sample app - but only in the designer */
.anvil-role-sample-app-info {
  display: none;
  font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  background-color: #222;
  color: #fff;
  border-radius: 4px;
  padding: 8px 10px 4px;
}

.anvil-designer .anvil-role-sample-app-info, .designer .anvil-role-sample-app-info {
  display: block;
}

.anvil-role-sample-app-info h2 {
  font-size: 20px;
  margin-top: 4px;
}

.anvil-role-sample-app-info code {
    background-color: var(--anvil-color-Primary-500-268b);
    font-weight: 600;
    color: white;
}
</style><style class="darkreader darkreader--sync" media="screen"></style><meta name="darkreader" content="bddfdb9ddd0f45838c41dca1df32e12a"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #684b00 !important;
    border-color: #9e7e00 !important;
    color: #d7d4cf !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #1b4958 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #0f3a47 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #1e2021 !important;
}
.tou-uknfeu {
    background-color: #432c09 !important;
}
.tou-6i3zyv {
    background-color: #245d70 !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}
embed[type="application/pdf"][src="about:blank"] { filter: invert(100%) contrast(90%); }</style>


  <script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/node_modules/jquery/dist/jquery.min.js?sha=f7f6a5894f1d19ddad6f" crossorigin=""></script>
  <script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/node_modules/jquery-migrate/dist/jquery-migrate.min.js?sha=106fcd8d723eda7d92a2" crossorigin=""></script>

  
<style type="text/css">@font-face{font-family:'Didact Gothic';src:url(data:font/woff2;base64,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) format("woff");font-weight:normal;font-style:normal}
</style><style class="darkreader darkreader--sync" media="screen"></style><style id="dark-reader-style" type="text/css">@media screen {

}</style><style class="darkreader darkreader--sync" media="screen"></style></head>
<body class="anvil-show-banner">
<div id="anvil-header">
  <a href="https://anvil.works/?utm_source=app_banner" target="_blank" class="cta"><span class="anvil-banner-hidden-xs">Build web apps for free with</span><span class="anvil-banner-xs">Built with</span> Anvil</a>
  <a href="https://anvil.works/?utm_source=app_banner" target="_blank"><span class="anvil-banner-hidden-xs">Built with </span><img src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/img/logo-35.png?sha=5f59d191b2294cd7ce36" crossorigin=""></a>
</div>

<a id="anvil-badge" href="https://anvil.works/?utm_source=app_banner" target="_blank">
  <img src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/img/made-with-anvil.png?sha=4bc58b691e1babd9e6a3" crossorigin="">
</a>

<div class="anvil-root-container"><div id="appGoesHere"></div></div>

<div id="loadingSpinner" class="anvil-spinner" style="display: none; opacity: 0;">
    <svg class="anvil-spinner-svg" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><style>@keyframes anvil-chase{to{transform: rotate(360deg)}}@keyframes anvil-chase-dot{80%,to{transform: rotate(360deg)}}@keyframes anvil-scale-dot{0%,100%{transform: scale(1)}50%{transform: scale(.4)}}.anvil-spinner-g circle{transform-origin: 12px 2.5px;animation: anvil-scale-dot 2s ease-in-out infinite}.anvil-spinner-g &gt; g{transform-origin: center;animation: anvil-chase-dot 2s ease-in-out infinite}.anvil-spinner-svg{fill:currentColor;stroke:currentColor}</style><style class="darkreader darkreader--sync" media="screen"></style><g class="anvil-spinner-g" style="transform-origin:center;animation:anvil-chase 2.5s infinite linear both"><g style="animation-delay:-1.1s"><circle cx="12" cy="2.5" r="1.5" style="animation-delay:-1.1s"></circle></g><g style="animation-delay:-1s"><circle cx="12" cy="2.5" r="1.5" style="animation-delay:-1s"></circle></g><g style="animation-delay:-.9s"><circle cx="12" cy="2.5" r="1.5" style="animation-delay:-.9s"></circle></g><g style="animation-delay:-.8s"><circle cx="12" cy="2.5" r="1.5" style="animation-delay:-.8s"></circle></g><g style="animation-delay:-.7s"><circle cx="12" cy="2.5" r="1.5" style="animation-delay:-.7s"></circle></g><g style="animation-delay:-.6s"><circle cx="12" cy="2.5" r="1.5" style="animation-delay:-.6s"></circle></g></g></svg>
</div>


<div id="error-indicator" style="display: block; padding-left: 20px; padding-right: 20px; right: 20px;">
  <div style="float:left; width: 40px">
    <i class="glyphicon glyphicon-warning-sign" style="float:left; width: 40px;"></i>
  </div>
  <div style="float:right;">
    <a class="glyphicon glyphicon-remove" href="#" onclick="$('#error-indicator').hide(); return false;"></a>
  </div>
  <div class="headline">This app has experienced an error</div>
  <div class="message">Click for more information</div>
  <pre class="output">SyntaxError: bad input</pre>
  <div style="clear:both"></div>
</div>
<script>
  (function () {
    const spinner = document.getElementById("loadingSpinner");
    const getBgImage = (pseudo) => getComputedStyle(spinner, pseudo).backgroundImage;
    for (const pseudo of [undefined, "::after", "::before"]) {
        if (getBgImage(pseudo) !== "none") {
            const svg = spinner.querySelector("svg")
            svg && svg.style.setProperty("display", "none");
            return;
        }
    }
  }());
</script>

<script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/node_modules/html5-boilerplate/dist/js/vendor/modernizr-3.8.0.min.js?sha=99722b17ae2646a10f43" crossorigin=""></script>

<div id="dark_reader_root" style="all: initial !important"></div><!--<script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/node_modules/bootstrap/dist/js/bootstrap.min.js?sha=9ee2fcff6709e4d0d24b" crossorigin></script>-->
<script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/node_modules/bootstrap/dist/js/bootstrap.min.js?sha=14a09c1d8116fd5b43e4" crossorigin=""></script>
<script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/node_modules/moment/min/moment.min.js?sha=e22419e8154be2a34a95" crossorigin=""></script>
<script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/node_modules/moment-timezone/builds/moment-timezone-with-data-2012-2022.min.js?sha=20dc5916fdb1faed3c66" crossorigin=""></script>
<script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/js/lib/daterangepicker.min.js?sha=e3c3b5b294995ff8a57d" crossorigin=""></script>
<script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/js/lib/b64.js?sha=6ad16e1a53852095268b" crossorigin=""></script>
<script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/js/lib/bootstrap-notify.min.js?sha=2db9de4f5fc27837d429" crossorigin=""></script>

<script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/node_modules/js-yaml/dist/js-yaml.min.js?sha=af2ea794b435266465e5" crossorigin=""></script>

<!--   <script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/node_modules/core-js-bundle/minified.js?sha=90d19e92b7cd38fee6c8" crossorigin></script>
 -->

<script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/js/lib/skulpt.min.js?sha=3656823e43d7e6157640" crossorigin=""></script>
<script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/js/lib/skulpt-stdlib.js?sha=21d0ff4e620972bd0e3a" crossorigin=""></script>

<script src="https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/dist/runner2.bundle.js?sha=52d6b7185322471c441a" crossorigin=""></script>


<script>
  window.anvilCDNOrigin = "https://anvil.works/runtime-new";
  window.anvilAppOrigin = "https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R";
  window.anvilEnvironmentOrigin = "https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R";
  window.anvilSessionToken = "Q557RAOI7WAY5UV2FZPM22COXJ7JILXD=CPMQ1AqfruhKuJ7Uf5qbJsXTGX89";
  window.anvilVersion = "d02d8bda20cb8335dd4de952135871d85a56801a";
  window.anvilAppInfo = {"id":"KSKWODC3NEPJKJPD","branch":"main","environment":{"description":"Debug for salasalvardoerickfernando@gmail.com","tags":["debug"]}};
  window.anvilGoogleApiKey = "AIzaSyCn8yc8dmMNcmAn-e_K5HT7NX19csXUGUA";
  // docker-platform-server-base script adds sha's in html files - we put this variable here so that we can aggrissively cache the std-lib files
  // the std-lib is loaded dynamically in runner.js
  window.anvilSkulptLib = {
    1: "https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/js/lib/skulpt-stdlib-1.json?sha=249d8768bb46126d0aa2",
    2: "https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/js/lib/skulpt-stdlib-2.json?sha=733be17e0f599eeeea1d",
    3: "https://kskwodc3nepjkjpd.anvil.app/PJOKXTGSOMCUER3YFCIEKC7R/_/static/runtime/js/lib/skulpt-stdlib-3.json?sha=9dba54e5082288307122"
  };

  {
    // remove _anvil_session to prevent referrer links from including the session
    const url = new URL(window.location.href);
    url.searchParams.delete("_anvil_session");
    window.history.replaceState(window.history.state || {}, "Anvil App", url);
  }

  // 
$(function() {Sk.builtinFiles.files["anvil-services\/tables\/__init__.py"] = "from anvil.tables import *\nfrom anvil.tables import _page_size\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/__init__.py"] = "import time\n\nimport anvil.server\n\nfrom . import _config\nfrom ._base_classes import Row, SearchIterator, Table\nfrom ._errors import (\n    NoSuchColumnError,\n    QuotaExceededError,\n    RowDeleted,\n    TableError,\n    TransactionConflict,\n)\nfrom ._helpers import _hash_wrapper\n\n\n# Use old app tables by default\nclass AppTables(object):\n    cache = None\n\n    def __getattr__(self, name):\n        if AppTables.cache is None:\n            AppTables.cache = anvil.server.call(\"anvil.private.tables.get_app_tables\")\n\n        tbl = AppTables.cache.get(name)\n        if tbl is not None:\n            return tbl\n\n        raise AttributeError(\"No such app table: '%s'\" % name)\n\n    def __setattr__(self, name, val):\n        raise Exception(\"app_tables is read-only\")\n\n    def __iter__(self):\n        return AppTableIterator()\n\n\nclass AppTableIterator:\n    def __init__(self):\n        self._it = None\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        # because __iter__ can't suspend\n        if AppTables.cache is None:\n            AppTables.cache = anvil.server.call(\"anvil.private.tables.get_app_tables\")\n        if self._it is None:\n            self._it = AppTables.cache.keys().__iter__()\n        return next(self._it)\n\n    next = __next__\n\n\n_set_class = object.__dict__[\"__class__\"].__set__\n\n\ndef _lazy_replace_class(self):\n    if _config.get_client_config().get(\"enable_v2\"):\n        from . import v2\n\n        v2._app_tables._clear_cache()\n        _set_class(self, type(v2.app_tables))\n    else:\n        AppTables.cache = None\n        _set_class(self, AppTables)\n\n\ndef _wrap_dunder(method):\n    def wrapped(self, *args, **kws):\n        _lazy_replace_class(self)\n        return getattr(self, method)(*args, **kws)\n\n    return wrapped\n\n\nclass _LazyAppTables(object):\n    def __getattribute__(self, name):\n        _lazy_replace_class(self)\n        return getattr(self, name)\n\n    __setattr__ = _wrap_dunder(\"__setattr__\")\n    __getitem__ = _wrap_dunder(\"__getitem__\")\n    __dir__ = _wrap_dunder(\"__dir__\")\n    __iter__ = AppTables.__iter__\n\n\n_ThreadLocal = object\n\nif anvil.is_server_side():\n    try:\n        from anvil._threaded_server import ThreadLocal as _ThreadLocal\n    except ImportError:\n        pass\n\n\nclass _LazyContext(_ThreadLocal):\n    def __enter__(self):\n        global batch_update, batch_delete\n        if not _config.get_client_config().get(\"enable_v2\"):\n            batch_update.__class__ = batch_delete.__class__ = type(None)\n            return self.__enter__()\n\n        from .v2 import _batcher as _b\n\n        for obj, orig in zip(\n            (batch_update, batch_delete), (\"batch_update\", \"batch_delete\")\n        ):\n            obj.__class__ = type(getattr(_b, orig))\n            obj.__init__()\n            setattr(_b, orig, obj)\n        return self.__enter__()\n\n    def __exit__(self, *args):\n        assert not isinstance(self, _LazyContext)\n        return self.__exit__(*args)\n\n\ndef _clear_cache():\n    _config.reset_config()\n    _set_class(app_tables, _LazyAppTables)\n\n\nanvil.server._on_invalidate_client_objects(_clear_cache)\n\n\n#!defModuleAttr(anvil.tables)!1:\n# {\n# \tname: \"app_tables\",\n# \ttype: \"any\",\n# \tanvil$helpLink: \"\/docs\/data-tables\/data-tables-in-code\",\n# \t$doc: \"Access Table objects from the datatables services. You can access a Table object with dot notation e.g. `app_tables.my_table`. To access a table with strings use `getattr(app_tables, 'my_table')`. If no table is present an AttributeError will be thrown.\"\n# }\n#\napp_tables = _LazyAppTables()\nbatch_update = _LazyContext()\nbatch_delete = _LazyContext()\n# Not very nice but these references exist in uplink code\n# before we have a chance to know if we're using the v1\/v2 config option\n# we can't call anvil.server until the uplink has made a connetion\n\n\ndef get_table_by_id(table_id):\n    if _config.get_client_config().get(\"enable_v2\"):\n        from .v2 import get_table_by_id\n\n        return get_table_by_id(table_id)\n    raise TableError(\"get_table_by_id is only available in Accelerated Tables beta\")\n\n\n#!defModuleAttr(anvil.tables)!1:\n# {\n# \tname: \"app_tables\",\n# \ttype: \"any\",\n# \tanvil$helpLink: \"\/docs\/data-tables\/data-tables-in-code\",\n# \t$doc: \"Access Table objects from the datatables services. You can access a Table object with dot notation e.g. `app_tables.my_table`. To access a table with strings use `getattr(app_tables, 'my_table')`. If no table is present an AttributeError will be thrown.\"\n# }\n#\n\n\nclass Transaction:\n    def __init__(self, relaxed=False):\n        self._aborting = False\n        self._isolation = \"relaxed\" if relaxed else None\n\n    #!defMethod(anvil.tables.Transaction instance)!2: \"Begin the transaction\" [\"__enter__\"]\n    def __enter__(self):\n        anvil.server.call(\n            \"anvil.private.tables.open_transaction\", isolation=self._isolation\n        )\n        return self\n\n    #!defMethod(_)!2: \"End the transaction\" [\"__exit__\"]\n    def __exit__(self, e_type, e_val, tb):\n        anvil.server.call(\n            \"anvil.private.tables.close_transaction\",\n            self._aborting or e_val is not None,\n        )\n\n    #!defMethod(_)!2: \"Abort this transaction. When it ends, all write operations performed during it will be cancelled\" [\"abort\"]\n    def abort(self):\n        self._aborting = True\n\n\n#!defClass(anvil.tables,%Transaction)!:\n\n\n#!defFunction(anvil.tables,%,function,server_function)!2:\n# {\n# \t$doc: \"When applied to a function (as a decorator), the whole function will run in a data tables transaction. If it conflicts with another transaction, it will retry up to five times.\",\n# anvil$helpLink: \"\/docs\/data-tables\/transactions\"\n#  } [\"in_transaction\"]\ndef in_transaction(maybe_f=None, relaxed=None):\n    # we don't want to import this on the client unnecessarily\n    import functools\n\n    def wrap(f):\n        @functools.wraps(f)\n        def new_f(*args, **kwargs):\n            n = 0\n            while True:\n                try:\n                    with Transaction(relaxed=relaxed):\n                        return f(*args, **kwargs)\n                except TransactionConflict:\n                    # lazy load random incase we make random.js a slow path on the client\n                    import random\n\n                    n += 1\n                    if n == 18:\n                        raise\n                    # print(f\"RETRYING TXN {n}\")\n                    # Max total sleep time is a little under 150 seconds (avg 75), so server calls will timeout before this finishes usually.\n                    sleep_amt = random.random() * (1.5**n) * 0.05\n                    try:\n                        time.sleep(sleep_amt)\n                    except:\n                        anvil.server.call(\"anvil.private._sleep\", sleep_amt)\n\n        try:\n            reregister = f._anvil_reregister\n        except AttributeError:\n            pass\n        else:\n            reregister(new_f)\n\n        return new_f\n\n    if maybe_f is None:\n        return wrap\n    else:\n        return wrap(maybe_f)\n\n\n#!defFunction(anvil.tables,_,column_name,ascending=)!2: \"Sort the results of this table search by a particular column. Default to ascending order.\" [\"order_by\"]\n@anvil.server.portable_class\nclass order_by(object):\n    def __init__(self, column_name, ascending=True):\n        self.column_name = column_name\n        self.ascending = ascending\n\n    __hash__, __eq__ = _hash_wrapper(\"column_name\", \"ascending\")\n\n\n# backward compatability\nfrom .query import fetch_only\nfrom .query import page_size as _page_size\n\n\n#!defFunction(anvil.tables,%,[via_host=],[via_port=])!2: \"Get a Postgres connection string for accessing this app's Data Tables via SQL.\\n\\nThe returned string includes temporary login credentials and sets the search path to a schema representing this app's Data Table environment.\\n\\nYou can override the host and port for the database connection to connect via a secure tunnel.\\n\\n(Available on the Dedicated Plan only.)\" [\"get_connection_string\"]\ndef get_connection_string(via_host=None, via_port=None):\n    return anvil.server.call(\n        \"anvil.private.get_direct_postgres_connection_string\",\n        via_host=via_host,\n        via_port=via_port,\n    )\n\n\n#!defMethod(table row, **column_values)!2: \"Add a row to the data table. Use keyword arguments to specify column values.\" [\"add_row\"]\n#!defMethod(client readable view)!2: \"Return a view on the table that can be read by client code. Use keyword arguments to specify view restrictions\" [\"client_readable\"]\n#!defMethod(client writable view)!2: \"Return a view on the table that can be written by client code. Use keyword arguments to specify view restrictions. This does not give the client write access to other tables referred to by the table.\" [\"client_writable\"]\n#!defMethod(client writable view)!2: \"Return a view on this table that can be written by client code. Use keyword arguments to specify view restrictions.\" [\"client_writable_cascade\"]\n#!defMethod(_)!2: \"Delete all the rows from the data table\" [\"delete_all_rows\"]\n#!defMethod(_)!2: \"Get a single matching row from the data table whose columns match the keyword arguments. Returns None if no matching row exists, and raises an exception if more than one row matches.\\n\\nEg: app_tables.table_1.get(name='John Smith')\" [\"get\"]\n#!defMethod(row,id)!2: \"Get the matching row from this data table, by its unique ID\" [\"get_by_id\"]\n#!defMethod(bool,row)!2: \"Returns true if the table (or view) contains the provided row.\" [\"has_row\"]\n#!defMethod(list of dicts)!2: \"Get the spec for the table as a list of dicts. Each dict contains the name and type of a column.\" [\"list_columns\"]\n#!defMethod(Row or None)!2: \"Get rows from a data table. If you specify keyword arguments, you will retrieve only rows whose columns match those values.\\n\\nEg: app_tables.table_1.search(name='John Smith')\" [\"search\"]\n#!defMethod(Media object, [escape_for_excel=False])!2: \"Get the table in CSV format, optionally escaped for use in Excel. Returns a downloadable Media object; use its url property.\" [\"to_csv\"]\n#!defClassNoConstructor(anvil.tables,#Table)!1: \"A table returned from app_tables\"\n\n#!defMethod(Media object, [escape_for_excel=False])!2: \"Get the results of the SearchIterator in CSV format, optionally escaped for use in Excel. Returns a downloadable Media object; use its url property.\" [\"to_csv\"]\n#!defClassNoConstructor(anvil.tables,#SearchIterator)!1: \"An iterator of table rows returned from a search()\";\n\n\n#!defMethod(_)!2: \"Delete the row from its data table\" [\"delete\"]\n#!defMethod(id)!2: \"Get the unique ID of the table row\" [\"get_id\"]\n#!defMethod(_,**column_values)!2: \"update the data for multiple columns\" [\"update\"]\n#!defClassNoConstructor(anvil.tables,#Row)!1: \"A table row\";\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/query.py"] = "from anvil.server import portable_class\n\nfrom ._helpers import _hash_wrapper\n\n# Don't load v2 code unless v2 is imported. v2._load_hacks will inject this for us.\n# from .v2._refs import make_refs as _make_refs\n_make_refs = lambda x: x\n\n\n\n\nclass _pattern_query(object):\n    def __init__(self, pattern):\n        self.pattern = pattern\n\n    __hash__, __eq__ = _hash_wrapper(\"pattern\")\n\n\nclass _value_query(object):\n    def __init__(self, value):\n        self.value = value\n\n    __hash__, __eq__ = _hash_wrapper(\"value\")\n\n\nclass _of_query(object):\n    def __init__(self, *args, **kwargs):\n        self.args = _make_refs(args)\n        self.kwargs = _make_refs(kwargs)\n\n    def __hash__(self):\n        return hash(self.args + tuple(sorted(self.kwargs.items())))\n\n    def __eq__(self, other):\n        if type(other) is not type(self):\n            return NotImplemented\n        return self.args == other.args and self.kwargs == other.kwargs\n\n\n#!defFunction(anvil.tables.query,_,pattern)!2: \"Match values using a case-sensitive LIKE query, using the % wildcard character.\" [\"like\"]\n@portable_class\nclass like(_pattern_query):\n    pass\n\n\n#!defFunction(anvil.tables.query,_,pattern)!2: \"Match values using a case-insensitive ILIKE query, using the % wildcard character.\" [\"ilike\"]\n@portable_class\nclass ilike(_pattern_query):\n    pass\n\n\n#!defFunction(anvil.tables.query,_,value)!2: \"Match values greater than the provided value.\" [\"greater_than\"]\n@portable_class\nclass greater_than(_value_query):\n    pass\n\n\n#!defFunction(anvil.tables.query,_,value)!2: \"Match values less than the provided value.\" [\"less_than\"]\n@portable_class\nclass less_than(_value_query):\n    pass\n\n\n#!defFunction(anvil.tables.query,_,value)!2: \"Match values greater than or equal to the provided value.\" [\"greater_than_or_equal_to\"]\n@portable_class\nclass greater_than_or_equal_to(_value_query):\n    pass\n\n\n#!defFunction(anvil.tables.query,_,value)!2: \"Match values less than or equal to the provided value.\" [\"less_than_or_equal_to\"]\n@portable_class\nclass less_than_or_equal_to(_value_query):\n    pass\n\n\n#!defFunction(anvil.tables.query,_,min,max,[min_inclusive=True],[max_inclusive=False])!2: \"Match values between the provided min and max, optionally inclusive.\" [\"between\"]\ndef between(min, max, min_inclusive=True, max_inclusive=False):\n    return all_of(\n        greater_than_or_equal_to(min) if min_inclusive else greater_than(min),\n        less_than_or_equal_to(max) if max_inclusive else less_than(max),\n    )\n\n\n#!defFunction(anvil.tables.query,_,query,[raw=False])!2: \"Match values that match the provided full-text search query.\" [\"full_text_match\"]\n@portable_class\nclass full_text_match(object):\n    def __init__(self, query, raw=False):\n        self.query = query\n        self.raw = raw\n\n    __hash__, __eq__ = _hash_wrapper(\"query\", \"raw\")\n\n\n#!defFunction(anvil.tables.query,_,*query_expressions)!2: \"Match all query parameters given as arguments and keyword arguments\" [\"all_of\"]\n@portable_class\nclass all_of(_of_query):\n    pass\n\n\n#!defFunction(anvil.tables.query,_,*query_expressions)!2: \"Match any query parameters given as arguments and keyword arguments\" [\"any_of\"]\n@portable_class\nclass any_of(_of_query):\n    pass\n\n\n#!defFunction(anvil.tables.query,_,*query_expressions)!2: \"Match none of the query parameters given as arguments and keyword arguments\" [\"none_of\"]\n@portable_class\nclass none_of(_of_query):\n    pass\n\n\n#!defFunction(anvil.tables.query,_,*query_expressions)!2: \"Match none of the query parameters given as arguments and keyword arguments\" [\"not_\"]\nnot_ = none_of\n\n#!defFunction(anvil.tables.query,_,rows)!2: \"Define the number of rows that are fetched per round trip to the server.\" [\"page_size\"]\n@portable_class\nclass page_size(object):\n    def __init__(self, rows):\n        self.rows = rows\n\n    __hash__, __eq__ = _hash_wrapper(\"rows\")\n\n\n@portable_class(\"anvil.tables.fetch_only\")\nclass fetch_only(object):\n    def __init__(self, *only_cols, **linked_cols):\n        spec = {}\n        for col in only_cols:\n            if not isinstance(col, str):\n                raise TypeError(\"columns must be strings\")\n            spec[col] = True\n        for col, only in linked_cols.items():\n            if not isinstance(only, fetch_only):\n                raise TypeError(\"keyword arguments must use q.fetch_only()\")\n            spec[col] = only.spec\n        self.spec = spec\n\n    def _hashable(self, val):\n        if val is True:\n            return val\n        return self._as_tuple(val)\n\n    def _as_tuple(self, spec):\n        return tuple((col_name, self._hashable(val)) for col_name, val in sorted(spec.items()))\n\n    def __hash__(self):\n        return hash(self._as_tuple(self.spec))\n\n    def __eq__(self, other):\n        if type(other) is not type(self):\n            return NotImplemented\n        return other.spec == self.spec\n\n\n@portable_class\nclass only_cols(object):\n    def __init__(self, *cols):\n        self.cols = tuple(sorted(cols))\n\n    __hash__, __eq__ = _hash_wrapper(\"cols\")\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/_helpers.py"] = "def _hash_wrapper(*params):\n    # this makes query objects cachable as keys of dictionaries\n    def _mk_tuple(self):\n        return tuple(getattr(self, param) for param in params)\n\n    def __hash__(self):\n        return hash(_mk_tuple(self))\n\n    def __eq__(self, other):\n        if type(other) is not type(self):\n            return NotImplemented\n        return _mk_tuple(self) == _mk_tuple(other)\n\n    return __hash__, __eq__\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/_errors.py"] = "import anvil.server\n\n\n#!defMethod()!2: \"Superclass of all table exceptions\" [\"__init__\"]\n#!defClass(anvil.tables,TableError,__builtins__..Exception)!:\nclass TableError(anvil.server.AnvilWrappedError):\n    pass\n\n\n#!defMethod()!2: \"Raised when attempting to accessing a table row that has been deleted - for example, accessing a row after calling its delete() method, or following a link to a deleted row.\" [\"__init__\"]\n#!defClass(anvil.tables,RowDeleted,anvil.tables.TableError)!:\nclass RowDeleted(TableError):\n    pass\n\n\n#!defMethod()!2: \"Raised when attempting to access a column that does not exist in this table.\" [\"__init__\"]\n#!defClass(anvil.tables,NoSuchColumnError,anvil.tables.TableError)!:\nclass NoSuchColumnError(TableError):\n    pass\n\n\n#!defMethod()!2: \"Raised when a transaction conflicts and has been aborted.\" [\"__init__\"]\n#!defClass(anvil.tables,TransactionConflict,anvil.tables.TableError)!:\nclass TransactionConflict(TableError):\n    pass\n\n\n#!defMethod()!2: \"Raised when an app has exceeded its quota.\" [\"__init__\"]\n#!defClass(anvil.tables,QuotaExceededError,anvil.tables.TableError)!:\nclass QuotaExceededError(TableError):\n    pass\n\n\nanvil.server._register_exception_type(\"anvil.tables.TransactionConflict\", TransactionConflict)\nanvil.server._register_exception_type(\"anvil.tables.TableError\", TableError)\nanvil.server._register_exception_type(\"anvil.tables.RowDeleted\", RowDeleted)\nanvil.server._register_exception_type(\"anvil.tables.NoSuchColumnError\", NoSuchColumnError)\nanvil.server._register_exception_type(\"anvil.tables.QuotaExceededError\", QuotaExceededError)\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/_config.py"] = "import anvil\n\n_config = None\n\n\ndef get_client_config():\n    global _config\n    if _config is not None:\n        return _config\n    _config = anvil._get_service_client_config(\"\/runtime\/services\/tables.yml\") or {}\n    return _config\n\ndef reset_config():\n    global _config\n    _config = None";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/_base_classes.py"] = "class AppTables(object):\n    def __repr__(self):\n        return \"<anvil.tables.{} object>\".format(type(self).__name__)\n\n\nclass AbstractTableClass(object):\n    __slots__ = ()\n    _instead = None\n\n    def __new__(cls, *args, **kwargs):\n        raise TypeError(\n            \"Can't create a {} object. Use {} instead.\".format(\n                cls.__name__, cls._instead\n            )\n        )\n\n    def __repr__(self):\n        return \"<anvil.tables.{} object>\".format(type(self).__name__)\n\n    def __dir__(self):\n        # TODO should we keep this?\n        # remove private attributes and methods from the dir\n        return [\n            key\n            for key in object.__dir__(self)\n            if (not key.startswith(\"_\")) or key.startswith(\"__\")\n        ]\n\n\nclass Table(AbstractTableClass):\n    _instead = \"app_tables.my_table\"\n\n\nclass SearchIterator(AbstractTableClass):\n    _instead = \"app_tables.my_table.search()\"\n\n\nclass Row(AbstractTableClass):\n    __slots__ = ()\n    _instead = \"app_tables.my_table.add_row()\"\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/v2\/__init__.py"] = "from .._base_classes import Row, SearchIterator, Table  # noqa: F401\nfrom . import _load_hacks  # noqa: F401\nfrom ._app_tables import app_tables, get_table_by_id\n\n# from ._batcher import batch_delete, batch_update\n\n__all__ = [\"app_tables\", \"get_table_by_id\"]\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/v2\/_app_tables.py"] = "import anvil.server\n\nfrom .._base_classes import AppTables as BaseAppTables\nfrom ._constants import SERVER_PREFIX\nfrom ._table import Table\n\n_table_cache = None\n\n\ndef _fill_cache():\n    global _table_cache\n    if _table_cache is None:\n        _table_cache = anvil.server.call(SERVER_PREFIX + \"get_app_tables\")\n    return _table_cache\n\n\ndef _clear_cache():\n    global _table_cache\n    _table_cache = None\n\n\nclass AppTableIterator:\n    def __init__(self):\n        self._it = None\n\n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self._it is None:\n            self._it = _fill_cache().__iter__()\n        return next(self._it)\n    \n    next = __next__\n\n\nclass AppTables(BaseAppTables):\n    def __getattribute__(self, name):\n        # use __getattribute__ so that we prioritise the table name\n        try:\n            return self[name]\n        except KeyError:\n            return object.__getattribute__(self, name)\n\n    def __getitem__(self, name):\n        cache = _fill_cache()\n        table_args = cache[name]\n        return Table._create(*table_args)\n\n    def __setattr__(self, name, val):\n        raise AttributeError(\"app_tables is read-only\")\n\n    def __dir__(self):\n        return object.__dir__(self) + list(_fill_cache().keys())\n    \n    def __iter__(self):\n        return AppTableIterator()\n\n\n\ndef get_table_by_id(table_id):\n    table_args = anvil.server.call(SERVER_PREFIX + \"get_table_by_id\", table_id)\n    return table_args and Table._create(*table_args)\n\n\napp_tables = AppTables()\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/v2\/_batcher.py"] = "import anvil\nimport anvil.server\n\nfrom ._constants import NOT_FOUND, SERVER_PREFIX\nfrom ._utils import ThreadLocal\n\nPREFIX = SERVER_PREFIX + \"row.\"\n_make_refs = None  # Circular import\n\n\nclass _Batcher(ThreadLocal):\n    _name = \"\"\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = ThreadLocal.__new__(cls)\n        return cls._instance\n\n    def __init__(self):\n        self._active = False\n        self._updates = []\n        self._buffer = {}\n        self._func = PREFIX + self._name\n\n    @property\n    def active(self):\n        return self._active\n\n    def push(self, cap, update=False, on_behalf_of_client=False):\n        self._updates.append((cap, update, on_behalf_of_client))\n\n    def reset(self):\n        self._active = False\n        self._updates.clear()\n        self._buffer.clear()\n\n    def __enter__(self):\n        if self._active:\n            raise RuntimeError(\"nested batching is not suppported\")\n        self._active = True\n\n    def get_args(self, updates):\n        raise NotImplementedError\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        updates = self._updates\n        try:\n            if exc_value is None and updates:\n                anvil.server.call(self._func, self.get_args(updates))\n                for cap, update, _kws in updates:\n                    cap.send_update(update)\n        finally:\n            self.reset()\n\n\nclass BatchUpdate(_Batcher):\n    _name = \"batch_update\"\n\n    def push(self, cap, update, on_behalf_of_client):\n        self._updates.append((cap, update, on_behalf_of_client))\n        self._buffer.setdefault(cap, {}).update(update)\n\n    def get_updates(self, cap):\n        return self._buffer.get(cap, {})\n\n    def read(self, cap, key):\n        return self.get_updates(cap).get(key, NOT_FOUND)\n\n    def get_args(self, updates):\n        global _make_refs\n        if _make_refs is None:\n            from ._refs import make_refs  # circular import\n\n            _make_refs = make_refs\n\n        return [(cap, _make_refs(update), on_behalf_of_client) for cap, update, on_behalf_of_client in updates]\n\n\nclass BatchDelete(_Batcher):\n    _name = \"batch_delete_2\"\n\n    def get_args(self, updates):\n        return [(cap, on_behalf_of_client) for cap, _, on_behalf_of_client in updates]\n\n\nbatch_update = BatchUpdate()\nbatch_delete = BatchDelete()\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/v2\/_constants.py"] = "import anvil.server\n\n# USED as an argument to the \"create_view\" private method\nREAD = \"r\"\nWRITE = \"rw\"\nCASCADE = \"rwc\"\nKNOWN_PERMS = (READ, WRITE, CASCADE)\n\nNOT_FOUND = object()\nCAP_KEY = \"c\"\n\nSINGLE = \"link_single\"\nMULTIPLE = \"link_multiple\"\nDATETIME = \"datetime\"\nMEDIA = \"media\"\n\nSHARED_DATA_KEY = \"anvil.tables\"\n\nSERVER_PREFIX = \"anvil.private.tables.v2.\"\n\n\n@anvil.server.portable_class(\"anvil.tables.v2.UNCACHED\")\nclass _UncachedType(object):\n    _instance = None\n\n    def __new__(cls):\n        self = cls._instance\n        if self is None:\n            cls._instance = self = object.__new__(cls)\n        return self\n\n    def __repr__(self):\n        return \"UNCACHED\"\n\n    @classmethod\n    def __new_deserialized__(cls, data, info):\n        return UNCACHED\n\n    def __serialize__(self, info):\n        return None\n\n\nUNCACHED = _UncachedType()\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/v2\/_load_hacks.py"] = "# For the sake of a soft roll-out, we don't want to load v2 code implicitly\n# from anvil.tables.query, but that module needs access to `make_refs` if we're\n# using v2. So we inject it (only) when v2 loads.\n\nfrom .. import query\nfrom . import _refs\n\nquery._make_refs = _refs.make_refs\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/v2\/_model.py"] = "import anvil\nfrom anvil.server import AnvilWrappedError, portable_class\n\nfrom .._errors import NoSuchColumnError\nfrom ._constants import NOT_FOUND\n\nrow_cls_by_id = {}\n\nglobal _Row\n\n\ndef getattr_impl(self, attr):\n    try:\n        return self[attr]\n    except (AnvilWrappedError, NoSuchColumnError):\n        raise AttributeError(attr)\n\n\ndef setattr_impl(self, attr, val):\n    # until we have a _anvil namespace we're not ready to set attributes\n    if attr in _Row.__slots__:\n        # we have a private attribute - we could also do something crazy like in\n        # Row's implementation only call obj_setattr implementation\n        object.__setattr__(self, attr, val)\n    else:\n        self[attr] = val\n\n\ndef _clear_cache():\n    # private method for clearing the cache\n    row_cls_by_id.clear()\n\n\ndef get_base_model_cls(table_id):\n    cls = row_cls_by_id.get(table_id)\n    if cls is not None:\n        return cls\n\n    global _Row\n    from ._app_tables import _table_cache\n    from ._row import Row as _Row\n\n    _table_cache = _table_cache or {}\n\n    tb_name = next(\n        (name for name, args in (_table_cache).items() if str(args[-1]) == table_id),\n        None,\n    )\n\n    class Row(_Row):\n        __slots__ = ()\n        _Row_model_ = None\n        _Row_permissions_ = {\"update\": False, \"create\": False, \"delete\": False}\n        _Row_buffered_ = False\n\n        def __new__(cls, **buffer):\n            self = object.__new__(cls)\n            self._anvil_setup(None, table_id, None, buffer=buffer)\n            return self\n\n        @classmethod\n        def _do_create(cls, buffer, from_client):\n            from . import get_table_by_id\n\n            on_behalf_of_client = cls._anvil_on_behalf_of_client(\"create\", from_client)\n            table = get_table_by_id(table_id)\n            return table._do_add_row(buffer, on_behalf_of_client)\n\n        def __init_subclass__(\n            cls,\n            attrs=False,\n            buffered=False,\n            client_writable=False,\n            client_updatable=NOT_FOUND,\n            client_creatable=NOT_FOUND,\n            client_deletable=NOT_FOUND,\n            **kws,\n        ):\n            for attr in (\"__deserialize__\", \"__serialize__\", \"save\"):\n                if getattr(cls, attr, None) is not getattr(Row, attr, None):\n                    msg = \"It is not possible to customize the method {} for {}.{}\".format(\n                        attr, cls.__module__, cls.__name__\n                    )\n                    raise TypeError(msg)\n\n            cls._Row_prefix_ = \"{}.{}\".format(cls.__module__, cls.__name__)\n            if attrs and not hasattr(cls, \"__getattr__\"):\n                cls.__getattr__ = getattr_impl\n                cls.__setattr__ = setattr_impl\n\n            if buffered:\n                cls._Row_buffered_ = True\n\n            cls._Row_permissions_ = {\n                perm_type: client_writable if value is NOT_FOUND else value\n                for perm_type, value in [\n                    (\"update\", client_updatable),\n                    (\"create\", client_creatable),\n                    (\"delete\", client_deletable),\n                ]\n            }\n\n            # models are portable by default\n            # the first subclass gets registered\n            # subsequent models use the same name\n            # A model can override this in advanced use cases e.g. uplink implementations\n            if Row._Row_model_ is Row:\n                portable_class(cls)\n            else:\n                name = cls.SERIALIZATION_INFO[0]\n                portable_class(name)(cls)\n\n            Row._Row_model_ = cls\n\n    # This allows us to pretend that the model class is the Row class for serialization\n    Row.__name__ = _Row.__name__\n    Row.__module__ = _Row.__module__\n    Row.__qualname__ = _Row.__qualname__\n\n    Row._Row_model_ = Row\n    if tb_name:\n        Row._Row_prefix_ = \"app_tables.{}.Row\".format(tb_name)\n    row_cls_by_id[table_id] = Row\n\n    # we'll be overriding the base Row class in the portable classes registry\n    # But that's fine since Row._anvil_create checks the correct Row subclass to __new__\n    return portable_class(Row)\n\n\ndef get_model_cls(table_id):\n    return get_base_model_cls(table_id)._Row_model_\n\n\ndef serialize_model(table_id, force=False):\n    model = get_model_cls(table_id)\n    if model is None or model is row_cls_by_id.get(table_id) and not force:\n        return None\n    return model\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/v2\/_refs.py"] = "import anvil.server\nfrom anvil.server import portable_class\n\nfrom ._row import Row, _is_draft\n\n# Helpful classes for table methods that include Rows\/SearchIterators\n# But sending the Row across the wire is unnecessary\n# We shouldn't be deserializing these objects but we include __deserialize__ for completeness\n\n\nclass _Ref(object):\n    def __init__(self, cap):\n        self.cap = cap\n\n    def __hash__(self):\n        return hash(self.cap)\n\n    def __serialize__(self, info):\n        return self.cap\n\n    def __deserialize__(self, cap, info):\n        self.cap = cap\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return NotImplemented\n        return self.cap == other.cap\n\n\n@portable_class(\"anvil.tables.v2._RowRef\")\nclass RowRef(_Ref):\n    pass\n\n\n@portable_class\nclass SearchIteratorRef(_Ref):\n    pass\n\n\ndef to_ref(obj):\n    ob_type = type(obj)\n    if ob_type in (list, tuple):\n        return tuple(to_ref(item) for item in obj)\n    elif isinstance(obj, Row):\n        if _is_draft(obj):\n            raise ValueError(\n                \"It looks like you're trying to write a draft as a linked row. This is not allowed.\"\n                \"Either use row.buffer_changes(True), or save the draft first.\"\n                \" (Found {!r})\".format(obj)\n            )\n        elif obj._anvil.cap is None:\n            raise RuntimeError(\"Row has no capability\")\n        return RowRef(obj._anvil.cap)\n    return obj\n\n\ndef make_refs(args_or_kws):\n    if type(args_or_kws) is dict:\n        return {key: to_ref(val) for key, val in args_or_kws.items()}\n    else:\n        return tuple(to_ref(val) for val in args_or_kws)\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/v2\/_row.py"] = "import anvil\nimport anvil.server\nfrom anvil.server import Capability\n\nfrom .._base_classes import Row as BaseRow\nfrom .._errors import NoSuchColumnError, RowDeleted, TableError\nfrom . import _batcher\nfrom ._constants import (\n    CAP_KEY,\n    DATETIME,\n    MEDIA,\n    MULTIPLE,\n    NOT_FOUND,\n    SERVER_PREFIX,\n    SHARED_DATA_KEY,\n    SINGLE,\n    UNCACHED,\n)\nfrom ._model import get_model_cls\nfrom ._utils import (\n    InternalDict,\n    ThreadLocal,\n    check_serialized,\n    clean_local_datetime,\n    init_spec_rows,\n    init_view_data,\n    merge_row_data,\n    validate_cap,\n)\n\nPREFIX = SERVER_PREFIX + \"row.\"\n_make_refs = None  # for circular imports\n_auto_create_is_enabled = NOT_FOUND\n\n\nclass _MODE:\n    NORMAL = 0\n    BUFFERED = 1\n    DRAFT = 2\n    # Buffered draft is when we explicitly call\n    # buffer_changes(True) on a draft\n    BUFFERED_DRAFT = 3\n\n\ndef _is_draft(row):\n    return row._anvil.mode is _MODE.DRAFT or row._anvil.mode is _MODE.BUFFERED_DRAFT\n\n\ndef _is_buffered(row):\n    return row._anvil.mode is not _MODE.NORMAL\n\n\ndef _copy(so):\n    if isinstance(so, list):\n        return [_copy(o) for o in so]\n    if isinstance(so, dict):\n        return {k: _copy(v) for k, v in so.items()}\n    return so\n\n\nclass _BufferedContext(object):\n    def __init__(self, row):\n        self._row = row\n\n    def __enter__(self):\n        mode = self._row._anvil.mode\n        if mode is _MODE.NORMAL:\n            self._row._anvil.mode = _MODE.BUFFERED\n        elif mode is _MODE.DRAFT:\n            self._row._anvil.mode = _MODE.BUFFERED_DRAFT\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self._row._anvil.buffer.clear()\n        if self._row._anvil.mode is _MODE.BUFFERED_DRAFT:\n            # revert back to a state where if we call save()\n            # then we will return to the default buffered mode\n            self._row._anvil.mode = _MODE.DRAFT\n        else:\n            self._row._anvil.mode = _MODE.NORMAL\n\n\n@anvil.server.portable_class\nclass Row(BaseRow):\n    __slots__ = (\"_anvil\",)\n    _Row_prefix_ = \"anvil.tables.Row\"\n    _Row_buffered_ = False\n    _Row_permissions_ = {\"update\": False, \"create\": False, \"delete\": False}\n\n    @classmethod\n    def _anvil_create(cls, view_key, table_id, row_id, spec=None, cap=None):\n        cls = get_model_cls(table_id)\n        buffer = {} if cls._Row_buffered_ else None\n        row = object.__new__(cls)\n        row._anvil_setup(view_key, table_id, row_id, spec, cap, buffer=buffer)\n        return row\n\n    def _anvil_setup(\n        self, view_key, table_id, row_id, spec=None, cap=None, buffer=None\n    ):\n        object.__setattr__(self, \"_anvil\", InternalDict())\n        self._anvil.view_key = view_key\n        self._anvil.table_id = table_id\n        self._anvil.id = row_id\n        self._anvil.cap = cap\n        self._anvil.cache = {}\n        self._anvil.spec = (\n            spec  # None when we are deserialized without access to table_data\n        )\n        self._anvil.cache_spec = spec[\"cache\"] if spec is not None else []\n        self._anvil.has_uncached = True\n        self._anvil.exists = True\n        self._anvil.dirty_spec = False  # used for serialization\n        if view_key is None:\n            self._anvil.mode = _MODE.DRAFT\n        elif buffer is not None:\n            self._anvil.mode = _MODE.BUFFERED\n        else:\n            self._anvil.mode = _MODE.NORMAL\n        self._anvil.buffer = buffer or {}\n\n        if cap is not None:\n            cap.set_update_handler(self._anvil_cap_update_handler)\n\n        return self\n\n    @classmethod\n    def _anvil_create_from_untrusted(cls, view_key, table_id, row_id, cap, local_data):\n        # check that we can trust the data that was sent!\n        row = local_data.get(cap)\n        if row is None:\n            row = local_data[cap] = cls._anvil_create(\n                view_key, table_id, row_id, None, cap\n            )\n        return row\n\n    @classmethod\n    def _anvil_create_from_trusted(cls, view_key, table_id, row_id, table_data):\n        table_id, row_id = str(table_id), str(row_id)\n        view_data = table_data[view_key]\n        rows = view_data[\"rows\"]\n        row_data = rows[row_id]\n        if isinstance(row_data, Row):\n            # prevent circular and use the created row from view_data\n            return row_data\n        spec = view_data[\"spec\"]\n        row = rows[row_id] = cls._anvil_create(view_key, table_id, row_id, spec)\n        # Replace the compact row_data with ourself\n        # This prevents circular references and has the benefit that\n        # we create the same rows and linked rows when creating Row objects from the same data\n        row._anvil_unpack(table_data, row_data)\n        if view_data.get(\"dirty_spec\"):\n            # a serialized row marked its spec as dirty after an update\n            row._anvil_clear_cache()\n        return row\n\n    @classmethod\n    def _anvil_create_from_local_values(\n        cls, view_key, table_id, row_id, spec, cap, local_items\n    ):\n        # the basic idea here is that we need to clean datetime objects and UNCACHE any linked rows\n        # where the view_key doesn't match what we expect from the col_spec\n        table_id, row_id = str(table_id), str(row_id)\n        row = cls._anvil_create(view_key, table_id, row_id, spec, cap)\n        clean_items = row._anvil_walk_local_items(local_items, missing=None)\n        row._anvil.cache.update(clean_items)\n        row._anvil_check_has_cached()\n        return row\n\n    # DESERIALIZE\n    @classmethod\n    def __new_deserialized__(cls, data, info):\n        table_data, local_data = info.shared_data(SHARED_DATA_KEY)\n        view_key, table_id, row_id, cap = data\n        if not info.remote_is_trusted:\n            validate_cap(cap, table_id, row_id)\n            table_data = None  # just incase\n        if not table_data:\n            # table_data None is not enough because we may be sending rows back and forward\n            # i.e. passing from client to server to client goes untrusted -> trusted -> client\n            return cls._anvil_create_from_untrusted(\n                view_key, table_id, row_id, cap, local_data\n            )\n        return cls._anvil_create_from_trusted(view_key, table_id, row_id, table_data)\n\n    def _anvil_unpack(self, table_data, row_data):\n        assert type(row_data) in (\n            list,\n            dict,\n        ), \"Unable to create Row object, bad row_data\"\n        spec = table_data[self._anvil.view_key][\"spec\"]\n        if self._anvil.spec is None:\n            self._anvil.spec = spec\n        cols = spec[\"cols\"] if spec is not None else []\n        initial_load = not bool(self._anvil.cache)\n        row_data_type = type(row_data)\n        # if the spec is None we must have a dict data type with a single cap key\n        # this potentially happens in (and is enforced by) serialization\n        if row_data_type is list:\n            unpacked_cache, cap = self._anvil_unpack_compact(\n                table_data, spec, cols, row_data, initial_load\n            )\n        elif row_data_type is dict:\n            unpacked_cache, cap = self._anvil_unpack_dict(\n                table_data, cols, row_data, initial_load\n            )\n        else:\n            raise TableError(\"the row data is invalid\")\n\n        assert type(cap) is Capability, \"invalid row_data\"\n        if self._anvil.cap is None:\n            self._anvil.cap = cap\n            cap.set_update_handler(self._anvil_cap_update_handler)\n        self._anvil.cache.update(unpacked_cache)\n        self._anvil_check_has_cached()\n\n    def _anvil_unpack_compact(self, table_data, spec, cols, row_data, initial_load):\n        # spec[\"cache\"] 1s matches the len(row_data) (+cap)\n        iter_row_data = iter(row_data)\n        unpacked_cache = {}\n        for col, is_cached in zip(cols, spec[\"cache\"]):\n            if is_cached:\n                val = self._anvil_unpack_linked(next(iter_row_data), col, table_data)\n            elif initial_load:\n                val = UNCACHED  # there's nothing there yet so fill it\n            else:\n                continue\n            unpacked_cache[col[\"name\"]] = val\n        return unpacked_cache, next(iter_row_data)\n\n    def _anvil_unpack_dict(self, table_data, cols, row_data, initial_load):\n        unpacked_cache = {}\n        for i, col in enumerate(cols):\n            val = row_data.pop(str(i), UNCACHED)\n            if val is UNCACHED and not initial_load:\n                # does this ever happen?\n                continue\n            unpacked_cache[col[\"name\"]] = self._anvil_unpack_linked(\n                val, col, table_data\n            )\n        cap = row_data.pop(CAP_KEY, None)\n        assert len(row_data) == 0, \"Invalid row data\"\n        return unpacked_cache, cap\n\n    def _anvil_unpack_linked(self, val, col, table_data):\n        table_id = col.get(\"table_id\")\n        if table_id is None or val is UNCACHED or val is None:\n            # not a linked row, or UNCACHED linked row (serialize cache dispute), or linked row is None\n            return val\n\n        # This line is failing for baker tilly - wrap in a try except\n        # it has since been reported on the forum and it seemed to be a client-side issue\n        # where the early return was not being triggered\n        try:\n            col_type, view_key = col[\"type\"], col[\"view_key\"]\n        except KeyError:\n            import json\n\n            msg = 'Failed to get \"view_key\" or \"type\" from col={!r}, found table_id={!r}, val={!r}'.format(\n                col, table_id, val\n            )\n            try:\n                _data = json.dumps(table_data, indent=2, default=lambda o: str(type(o)))\n                msg += \"\\n\\nTable data:\\n{}\".format(_data)\n            except Exception:\n                pass\n\n            raise KeyError(msg)\n\n        if col_type == SINGLE:\n            row_id = val\n            return Row._anvil_create_from_trusted(\n                view_key, table_id, row_id, table_data\n            )\n        elif col_type == MULTIPLE:\n            row_ids = val\n            return [\n                Row._anvil_create_from_trusted(view_key, table_id, row_id, table_data)\n                for row_id in row_ids\n            ]\n\n        raise AssertionError(\"bad col type with table_id\")\n\n    # SERIALIZATION\n    def __serialize__(self, info):\n        self._anvil_check_can_serialize()\n        table_data, local_data = info.shared_data(SHARED_DATA_KEY)\n        if table_data is not None and info.local_is_trusted:\n            self._anvil_merge_and_reduce(table_data, local_data)\n        else:\n            # We want to ensure we're not trying to send a linked draft or row that has buffered changes\n            # TODO - we could be a bit more efficient about this since we don't actually need the data!\n            self._anvil_merge_and_reduce({}, local_data)\n        return [\n            self._anvil.view_key,\n            self._anvil.table_id,\n            self._anvil.id,\n            self._anvil.cap,\n        ]\n\n    def _anvil_check_can_serialize(self, linked=False):\n        error = None\n        pre = \"Linked \" if linked else \"\"\n        if _is_draft(self):\n            error = \"Draft Rows cannot be serialized. Call save() first. (Found {!r})\"\n        elif self._anvil.buffer:\n            error = \"Rows with buffered changes cannot be serialized. Call save() or reset() first, (Found {!r})\"\n        if error:\n            raise anvil.server.SerializationError(pre + error.format(self))\n\n    def _anvil_merge_linked(self, val, col, g_table_data, local_data):\n        type = col[\"type\"]\n        if val is UNCACHED or val is None:\n            # maybe we were serialized and converted linked row(s) to UNCACHED\n            # or actually the linked row is None\n            pass\n        elif type == SINGLE:\n            row = val\n            val = row._anvil_merge_and_reduce(g_table_data, local_data)\n        elif type == MULTIPLE:\n            val = [row._anvil_merge_and_reduce(g_table_data, local_data) for row in val]\n        return val\n\n    def _anvil_make_row_data(self, g_table_data, local_data, cache_spec):\n        self._anvil_check_can_serialize(linked=True)\n        table_spec = self._anvil.spec\n        table_cols = table_spec[\"cols\"] if table_spec is not None else []\n        cache = self._anvil.cache\n        # we can't rely on the order of cache in python 2\n        cached_data = []\n        for i, (col, is_cached) in enumerate(zip(table_cols, cache_spec)):\n            if not is_cached:\n                continue\n            name = col[\"name\"]\n            val = self._anvil_merge_linked(cache[name], col, g_table_data, local_data)\n            cached_data.append((i, val))\n        cached_data.append((CAP_KEY, self._anvil.cap))\n        return cached_data\n\n    def _anvil_merge_and_reduce(self, g_table_data, local_data):\n        if check_serialized(self, local_data):\n            return int(self._anvil.id)\n        g_view_data = init_view_data(self._anvil.view_key, g_table_data)\n        table_spec, row_id, cache_spec = (\n            self._anvil.spec,\n            self._anvil.id,\n            self._anvil.cache_spec,\n        )\n\n        # We assert that there is no way for rows from the same view_key to have different col_specs\n        # This includes the order\n        # the only thing they may differ on is cache_specs\n        g_table_spec, g_table_rows = init_spec_rows(g_view_data, table_spec, cache_spec)\n        g_cache_spec = g_table_spec[\"cache\"] if g_table_spec is not None else None\n\n        if table_spec is not None and g_cache_spec is not None:\n            is_dirty = self._anvil.dirty_spec or len(cache_spec) != len(g_cache_spec)\n        else:\n            is_dirty = self._anvil.dirty_spec\n\n        if is_dirty:\n            g_view_data[\"dirty_spec\"] = True\n            cache_spec = []\n\n        cached_data = self._anvil_make_row_data(g_table_data, local_data, cache_spec)\n        existing = g_table_rows.get(row_id, [])\n\n        if not is_dirty and cache_spec == g_cache_spec and type(existing) is list:\n            row_data = [val for _, val in cached_data]\n        else:\n            row_data = {str(key): val for key, val in cached_data}\n\n        merge_row_data(row_id, row_data, g_table_rows, g_table_spec, cache_spec)\n        return int(row_id)\n\n    # PRIVATE METHODS\n    def _anvil_cap_update_handler(self, updates):\n        if updates is False:\n            # We've been deleted clear_cache so that\n            # server calls are required for data access\n            self._anvil_clear_cache()\n            self._anvil.mode = _MODE.NORMAL\n            self._anvil.buffer.clear()\n            self._anvil.exists = False\n            return\n        elif self._anvil.spec is None:\n            return\n        clean_items = self._anvil_walk_local_items(updates)\n        self._anvil.cache.update(clean_items)\n        for key in clean_items:\n            self._anvil.buffer.pop(key, None)\n        self._anvil_check_has_cached()\n\n    def _anvil_check_has_cached(self):\n        if self._anvil.spec is None:\n            return\n        self._anvil.cache_spec = [\n            int(self._anvil.cache[col[\"name\"]] is not UNCACHED)\n            for col in self._anvil.spec[\"cols\"]\n        ]\n        self._anvil.has_uncached = any(\n            val is UNCACHED for val in self._anvil.cache.values()\n        )\n\n    def _anvil_clear_cache(self):\n        # clearing the cache also clears the spec - this forces a call to the server to update a spec\n        self._anvil.spec = None\n        self._anvil.cache.clear()\n        self._anvil.cache_spec = []\n        self._anvil.has_uncached = True\n\n    def _anvil_fill_cache(self, fetch=None):\n        if fetch is not None:\n            uncached_keys = None if fetch is True else fetch\n        elif self._anvil.spec is None:\n            uncached_keys = None\n        elif self._anvil.has_uncached:\n            uncached_keys = [\n                key for key, val in self._anvil.cache.items() if val is UNCACHED\n            ]\n        else:\n            return  # no uncached values\n\n        table_data = anvil.server.call(PREFIX + \"fetch\", self._anvil.cap, uncached_keys)\n        rows = table_data[self._anvil.view_key][\"rows\"]\n        row_data = rows[self._anvil.id]\n        # Replace the compact row data with this Row instance\n        # so circular references don't clobber the data while we're unpacking.\n        rows[self._anvil.id] = self\n        self._anvil_unpack(table_data, row_data)\n\n    def _anvil_walk_local_items(self, items, missing=NOT_FOUND):\n        # We are about to put local items in the cache\n        # so check linked rows have valid view keys datetimes have tz.offset applied\n        items = items.copy()\n        rv = {}\n        cols = self._anvil.spec[\"cols\"]\n        for col in cols:\n            name, type = col[\"name\"], col[\"type\"]\n            val = items.pop(name, missing)\n            if val is NOT_FOUND:\n                continue\n            else:\n                rv[name] = _copy(val)\n            if val is UNCACHED or val is None:\n                continue\n            elif type == DATETIME:\n                rv[name] = clean_local_datetime(val)\n                continue\n            elif type == MEDIA:\n                rv[name] = UNCACHED  # we need to fetch a lazy media with a valid url\n                continue\n            elif type == SINGLE:\n                val = [val]\n            elif type != MULTIPLE:\n                continue\n            rows = val\n            expected_view_key = col[\"view_key\"]\n            if any(row._anvil.view_key != expected_view_key for row in rows):\n                rv[name] = UNCACHED\n        if len(items):\n            # more items than we should have - our col spec is no good anymore\n            self._anvil.dirty_spec = True\n            rv.update(items)\n        return rv\n\n    def _anvil_check_exists(self):\n        # only call this if we're not doing a server call\n        if not self._anvil.exists:\n            raise RowDeleted(\"This row has been deleted\")\n        elif _is_draft(self):\n            raise ValueError(\"This row is a draft and does not yet exist\")\n\n    # DUNDER METHODS\n    def __setattr__(self, attr, val):\n        raise AttributeError(\n            f\"Rows cannot have local state, trying to set {attr!r} attribute on {self!r}\"\n        )\n\n    def __iter__(self):\n        # call to __iter__ can't suspend\n        # so only do suspension stuff in __next__\n        # note that this will not get called for dict(row)\n        # keys() and __getitem__ wins for a call to dict\n        return RowIterator(self)\n\n    def __contains__(self, key):\n        return key in self.keys()\n\n    def __getitem__(self, key):\n        if not isinstance(key, str):\n            raise TypeError(\n                \"Row columns are always strings, not {}\".format(type(key).__name__)\n            )\n        if _is_buffered(self):\n            rv = self._anvil.buffer.get(key, NOT_FOUND)\n            if rv is not NOT_FOUND:\n                return _copy(rv)\n            if _is_draft(self):\n                return None\n\n        if _batcher.batch_update.active:\n            rv = _batcher.batch_update.read(self._anvil.cap, key)\n            if rv is not NOT_FOUND:\n                return _copy(rv)\n        if self._anvil.spec is None:\n            self._anvil_fill_cache()\n        hit = self._anvil.cache.get(key, NOT_FOUND)\n        if hit is UNCACHED:\n            # we have a spec now so we'll fetch the remaining columns\n            self._anvil_fill_cache()\n        elif hit is NOT_FOUND:\n            global _auto_create_is_enabled\n            if _auto_create_is_enabled is NOT_FOUND:\n                _auto_create_is_enabled = anvil.server.call(PREFIX + \"can_auto_create\")\n            if _auto_create_is_enabled:\n                # try to force fetch this key - incase we have a bad spec - i.e auto-columns\n                self._anvil_fill_cache([key])\n        else:\n            return _copy(hit)\n        try:\n            return _copy(self._anvil.cache[key])\n        except KeyError:\n            raise NoSuchColumnError(\"No such column '\" + key + \"'\")\n\n    def __setitem__(self, key, value):\n        return self.update(**{key: value})\n\n    def __eq__(self, other):\n        if not isinstance(other, Row):\n            return NotImplemented\n        if self is other:\n            return True\n        return (\n            self._anvil.id is not None\n            and other._anvil.id == self._anvil.id\n            and other._anvil.table_id == self._anvil.table_id\n        )\n\n    def __hash__(self):\n        if _is_draft(self):\n            raise ValueError(\"draft rows are unhashable\")\n        self._anvil_check_exists()\n        return hash((self._anvil.table_id, self._anvil.id))\n\n    def __repr__(self):\n        cls = type(self)\n        prefix = cls._Row_prefix_\n        if _is_draft(self):\n            return \"<{} (draft) object>\".format(prefix)\n\n        if self._anvil.spec is None:\n            return \"<{} object>\".format(prefix)\n\n        # custom reprs depending on type\n        def trunc_str(s):\n            return repr(s) if len(s) < 20 else repr(s[:17] + \"...\")\n\n        def dt_repr(d):\n            return \"datetime(\" + str(d) + \")\"\n\n        def d_repr(d):\n            return \"date(\" + str(d) + \")\"\n\n        printable_types = {\n            \"string\": trunc_str,\n            \"bool\": repr,\n            \"date\": d_repr,\n            \"datetime\": dt_repr,\n            \"number\": repr,\n        }\n\n        # Find cols that are both cached and easily printed\n        cache, cols = self._anvil.cache, self._anvil.spec[\"cols\"]\n        cached_printable_cols = [\n            (c[\"name\"], printable_types[c[\"type\"]], cache[c[\"name\"]])\n            for c in cols\n            if c[\"type\"] in printable_types and cache[c[\"name\"]] is not UNCACHED\n        ]\n        # Only keep the first 5\n        cached_printable_cols = cached_printable_cols[:5]\n        # Find all the remaining columns\n        num_remaning = len(cols) - len(cached_printable_cols)\n\n        vals = \", \".join(\n            \"{}={}\".format(name, None if val is None else meth(val))\n            for name, meth, val in cached_printable_cols\n        )\n\n        if not num_remaning:\n            and_more = \"\"\n        elif cached_printable_cols:\n            and_more = \", plus {} more column{}\".format(\n                num_remaning, \"s\" if num_remaning != 1 else \"\"\n            )\n        else:\n            and_more = \"{} column{}\".format(\n                num_remaning, \"s\" if num_remaning != 1 else \"\"\n            )\n\n        return \"<{}: {}{}>\".format(prefix, vals, and_more)\n\n    # PUBLIC API\n    def buffer_changes(self, buffered=None):\n        if buffered:\n            if _is_draft(self):\n                # we are explicitly setting the mode to buffered\n                # this effects the save behaviour\n                # this would be an unusual thing to do - but it does mean you can re-use logic between drafts and rows\n                self._anvil.mode = _MODE.BUFFERED_DRAFT\n            else:\n                self._anvil.mode = _MODE.BUFFERED\n            return _BufferedContext(self)\n        elif buffered is None:\n            # we don't start buffering until we enter the context manager\n            return _BufferedContext(self)\n        elif _is_draft(self):\n            # alternatively we could go to `DRAFT` mode from `BUFFERED_DRAFT` mode\n            raise ValueError(\n                \"Changes in a draft row must always be buffered\"\n                \" - call save() to convert to a realized row or reset to clear the buffer\"\n            )\n        else:\n            self._anvil.mode = _MODE.NORMAL\n            self._anvil.buffer.clear()\n\n    @property\n    def buffered_changes(self):\n        if _is_buffered(self):\n            return _copy(self._anvil.buffer)\n        else:\n            return None\n\n    def save(self):\n        # TODO - add a cascade argument and decide on the correct behaviour\n        # e.g. what happens if cascade is false but you have draft linked rows?\n        save_all(self)\n\n    def reset(self):\n        reset_all(self)\n\n    # deprecated\n    def get_id(self):\n        # For compatibility with LiveObjects\n        self._anvil_check_exists()\n        return \"[{},{}]\".format(self._anvil.table_id, self._anvil.id)\n\n    # TODO reinclude this api\n    # @property\n    # def id(self):\n    #     return self._anvil.id\n\n    # TODO reinclude this api\n    # @property\n    # def table_id(self):\n    #     return self._anvil.table_id\n\n    def get(self, key, default=None):\n        if key in self.keys():\n            return self[key]\n        return default\n\n    def keys(self):\n        if _is_draft(self):\n            return self._anvil.buffer.keys()\n        if self._anvil.spec is None:\n            # if we don't have a _spec we don't have any keys\n            # but we don't need to blindly call _fill_uncached: UNCACHED values are fine\n            self._anvil_fill_cache([])\n        return self._anvil.cache.keys()\n\n    def _anvil_get_view(self):\n        fetch = None\n        if _is_buffered(self):\n            fetch = [k for k in self.keys() if k not in self._anvil.buffer]\n        self._anvil_fill_cache(fetch)\n\n        view = _copy(self._anvil.cache)\n\n        if _batcher.batch_update.active:\n            batched = _batcher.batch_update.get_updates(self._anvil.cap)\n            view.update(_copy(batched))\n\n        if _is_buffered(self):\n            view.update(_copy(self._anvil.buffer))\n\n        return view\n\n    def items(self):\n        return self._anvil_get_view().items()\n\n    def values(self):\n        return self._anvil_get_view().values()\n\n    def update(*args, **new_items):\n        # avoid name conflicts with columns, could use (self, other, \/, **kws)\n        # but positioin only args not available in py2\/Skulpt\n        if not args:\n            raise TypeError(\"method 'update' of 'Row' object needs an argument\")\n        elif len(args) > 2:\n            raise TypeError(\"expected at most 1 argument, got %d\" % (len(args) - 1))\n        elif len(args) == 2:\n            new_items = dict(args[1], **new_items)\n        self = args[0]\n        if not new_items:\n            # backwards compatability hack\n            self._anvil_clear_cache()\n            return\n\n        if _is_buffered(self):\n            self._anvil.buffer.update(new_items)\n        elif not anvil.is_server_side() and type(self)._Row_permissions_[\"update\"]:\n            # If we are on the client and we are a client-updatable model, we should send updates via the\n            # server.\n            anvil.server.call(\"anvil.tables.v2._update_row_on_server\", self, new_items, [type(self)])\n        else:\n            self._do_update(new_items, not anvil.is_server_side())\n\n    def delete(self):\n        if not anvil.is_server_side() and type(self)._Row_permissions_[\"delete\"]:\n            # If we are a client-deletable model, we should send delete requests via the server\n            anvil.server.call(\"anvil.tables.v2._delete_row_on_server\", self, type(self))\n        else:\n            self._do_delete(not anvil.is_server_side())\n\n    def _do_delete(self, from_client):\n        on_behalf_of_client = self._anvil_on_behalf_of_client(\"delete\", from_client)\n\n        if _batcher.batch_delete.active:\n            return _batcher.batch_delete.push(self._anvil.cap, False, on_behalf_of_client)\n\n        anvil.server.call(PREFIX + \"delete\", self._anvil.cap, on_behalf_of_client)\n        self._anvil.cap.send_update(False)\n\n    def refresh(self, fetch=None):\n        if fetch is not None:\n            from ..query import fetch_only\n\n            if not isinstance(fetch, fetch_only):\n                raise TypeError(\n                    \"the second argument to refresh should be a q.fetch_only() object\"\n                )\n            fetch = fetch.spec\n        self._anvil_clear_cache()\n        self._anvil_fill_cache(fetch)\n        # Note: the underlying db values are fetched and the buffer remains unchanged\n\n    @classmethod\n    def _anvil_on_behalf_of_client(cls, permission, from_client):\n        # We're on the server, this request originated on the client, and the client doesn't have permission to do this\n        return (\n            anvil.is_server_side()\n            and from_client\n            and not cls._Row_permissions_[permission]\n        )\n\n    def _do_update(self, updates, from_client):\n        on_behalf_of_client = self._anvil_on_behalf_of_client(\"update\", from_client)\n        \n        if _batcher.batch_update.active:\n            # a batch update might be on_behalf_of_client, if we are called during a save\n            # and the save was from the client\n            # and one of the updates does not have client_updatable permissions set\n            return _batcher.batch_update.push(self._anvil.cap, updates, on_behalf_of_client)\n\n        global _make_refs\n        if _make_refs is None:\n            from ._refs import make_refs  # circular import\n\n            _make_refs = make_refs\n\n        anvil.server.call(\n            PREFIX + \"update\", self._anvil.cap, _make_refs(updates), on_behalf_of_client\n        )\n        self._anvil.cap.send_update(updates)\n\n    @classmethod\n    def _do_create(cls, buffer, from_client):\n        raise NotImplementedError(\"Must be implemented by a subclass\")\n\n\nclass RowIterator:\n    def __init__(self, row):\n        self._row = row\n        self._fill_required = row._anvil.spec is None and not _is_draft(row)\n        if _is_draft(row):\n            self._iter = iter(row._anvil.buffer.items())\n        else:\n            self._iter = iter(row._anvil.cache.items())\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self._fill_required:\n            self._row._anvil_fill_cache()\n            self.__init__(self._row)\n\n        key, value = next(self._iter)\n\n        if _batcher.batch_update.active:\n            batched = _batcher.batch_update.read(self._row._anvil.cap, key)\n            if batched is not NOT_FOUND:\n                value = batched\n\n        if not _is_draft(self._row) and key in self._row._anvil.buffer:\n            value = self._row._anvil.buffer[key]\n\n        if value is UNCACHED:\n            # fill the rest of the cache\n            # since we probably want all the items!\n            # we rely here on the _cache keys not changing during iteration\n            # which works since we've filled it with UNCACHED values that match our expected keys\n            self._row._anvil_fill_cache()\n            value = self._row._anvil.cache[key]\n\n        return (key, _copy(value))\n\n    next = __next__\n\n\nif anvil.is_server_side():\n    import anvil.tables\n\n    @anvil.tables.in_transaction(relaxed=True)\n    def _save_on_server(changes, from_client, models=None):\n        from . import get_table_by_id\n\n        drafts = []\n\n        for draft_info in changes[\"draft_info\"]:\n            table_id = draft_info[\"table_id\"]\n            table = get_table_by_id(table_id)\n            from ._model import get_model_cls\n\n            model = get_model_cls(table_id)\n            rv = model._do_create(draft_info[\"buffer\"], from_client)\n            if not isinstance(rv, table.Row):\n                raise Exception(\"Row._do_create() must return a Row\")\n            drafts.append(rv)\n\n        # create empty buffers for each draft\n        # these buffers will be filled with any links\/mulitlinks that contained drafts\n        # we couldn't include these changes with creation - so we write the changes later\n        draft_buffers = [{} for _ in changes[\"draft_info\"]]\n\n        for single in changes[\"single\"]:\n            # single has paths to drafts and we inject the crated drafts into the appropriate paths\n            path = single[\"path\"]\n            row_index = single[\"row\"]\n            row = drafts[row_index]\n            if path[0] == \"rows\":\n                buffer = changes[\"buffers\"][path[1]]\n            elif path[0] == \"drafts\":\n                buffer = draft_buffers[path[1]]\n            key = path[2]\n            buffer[key] = row\n\n        for multi in changes[\"multi\"]:\n            # multi has paths to drafts and we inject the crated drafts into the appropriate paths\n            path = multi[\"path\"]\n            rows = multi[\"rows\"]\n            for i, row in enumerate(rows):\n                if isinstance(row, int):\n                    rows[i] = drafts[row]\n            if path[0] == \"rows\":\n                buffer = changes[\"buffers\"][path[1]]\n            elif path[0] == \"drafts\":\n                buffer = draft_buffers[path[1]]\n            key = path[2]\n            buffer[key] = rows\n\n        with _batcher.batch_update:\n            for row, buffer in zip(changes[\"rows\"], changes[\"buffers\"]):\n                buffer = buffer or {}\n                table = get_table_by_id(row._anvil.table_id)\n                if not isinstance(row, Row):\n                    raise TypeError(\"changes['rows'] must consist of Row objects\")\n                row._do_update(buffer, from_client)\n\n            for row, buffer in zip(drafts, draft_buffers):\n                if not buffer:\n                    continue\n\n                table = get_table_by_id(row._anvil.table_id)\n                row._do_update(buffer, from_client)\n\n        return drafts\n\n    if anvil.server.context.type != \"uplink\":\n\n        @anvil.server.callable(\"anvil.tables.v2._save_on_server\")\n        def _wrap_save_on_server(changes, models=None):\n            return _save_on_server(changes, True, models)\n            \n        @anvil.server.callable(\"anvil.tables.v2._update_row_on_server\")\n        def _wrap_update_on_server(row, changes, models=None):\n            if not isinstance(row, Row):\n                raise TypeError(\"Must pass a table row\")\n            row._do_update(changes, True)\n\n        @anvil.server.callable(\"anvil.tables.v2._delete_row_on_server\")\n        def _wrap_delete_on_server(row, models=None):\n            if not isinstance(row, Row):\n                raise TypeError(\"Must pass a table row\")\n            row._do_delete(True)\n\n\ndef _walk_buffered_changes(row, changes, drafts, buffered, seen):\n    # Approach: we fill the changes dict with draft buffers, rows with bufferred changes and their buffers\n    # where drafts exist in any of the buffers we replace the value with None\n    # we keep track of the path to the where the draft was\n    # we do something similar with multilinke, but replace the element in the list with None\n    # when it comes to saving these changes, we fill the links and multi links after we've created the drafts\n\n    # we can't hash a draft, use the id, because to equal rows might have different buffered changes\n    row_key = id(row)\n    if row_key in seen:\n        return changes\n\n    seen[row_key] = {}\n    buffer = {}\n    path_start = \"rows\"\n    index = None\n\n    if _is_draft(row):\n        buffer = _copy(row._anvil.buffer)\n        index = len(drafts)\n        seen[row_key][\"index\"] = index\n        drafts.append(row)\n        changes[\"draft_info\"].append(\n            {\"buffer\": buffer, \"table_id\": row._anvil.table_id}\n        )\n        path_start = \"drafts\"\n\n    elif _is_buffered(row):\n        buffered.append(row)\n        buffer = _copy(row._anvil.buffer)\n        if buffer:\n            index = len(changes[\"rows\"])\n            changes[\"rows\"].append(row)\n            changes[\"buffers\"].append(buffer)\n\n    else:\n        assert not buffer, \"buffer should be empty\"\n\n    # now check for any linked drafts\n    for key, val in buffer.items():\n        if isinstance(val, Row):\n            _walk_buffered_changes(\n                val,\n                changes=changes,\n                seen=seen,\n                buffered=buffered,\n                drafts=drafts,\n            )\n\n            if _is_draft(val):\n                buffer[key] = None\n                val_index = seen[id(val)][\"index\"]\n                path = [path_start, index, key]\n                changes[\"single\"].append({\"path\": path, \"row\": val_index})\n\n        elif isinstance(val, list):\n            has_draft = False\n            for i, v in enumerate(val):\n                if isinstance(v, Row):\n                    _walk_buffered_changes(\n                        v,\n                        changes=changes,\n                        seen=seen,\n                        buffered=buffered,\n                        drafts=drafts,\n                    )\n\n                    if _is_draft(v):\n                        has_draft = True\n                        val[i] = seen[id(v)][\"index\"]\n\n            if has_draft:\n                changes[\"multi\"].append({\"path\": [path_start, index, key], \"rows\": val})\n                buffer[key] = None\n\n    if row._anvil.spec is None:\n        # we don't have anything in our cache that needs changing\n        return\n\n    # we don't need to worry about drafts in the cache\n    for val in row._anvil.cache.values():\n        if isinstance(val, Row):\n            _walk_buffered_changes(\n                val,\n                changes=changes,\n                seen=seen,\n                buffered=buffered,\n                drafts=drafts,\n            )\n        elif isinstance(val, list):\n            for v in val:\n                if isinstance(v, Row):\n                    _walk_buffered_changes(\n                        v,\n                        changes=changes,\n                        seen=seen,\n                        buffered=buffered,\n                        drafts=drafts,\n                    )\n\n\ndef _initialize_drafts(server_drafts, drafts):\n    # we now walk the rows that need changing\n    # we clear the buffer for each row\n    # and we update the buffer mode\n    # when we have drafts, the response should include capabilities that we need to map to the draft\n    assert len(server_drafts) == len(drafts), \"Draft count doesn't match response count\"\n    for server_draft, draft in zip(server_drafts, drafts):\n        draft_internal = draft._anvil\n        assert (\n            draft_internal.table_id == server_draft._anvil.table_id\n        ), \"Table ids don't match\"\n        object.__setattr__(draft, \"_anvil\", _copy(server_draft._anvil))\n        draft._anvil.buffer = draft_internal.buffer\n        draft._anvil.mode = draft_internal.mode\n\n        # mode switches to the default mode - unless we have explicitly set buffer_changes(True)\n        if draft._anvil.mode is _MODE.BUFFERED_DRAFT:\n            # explicitly set to buffered mode\n            draft._anvil.mode = _MODE.BUFFERED\n        elif type(draft)._Row_buffered_:\n            draft._anvil.mode = _MODE.BUFFERED\n        else:\n            draft._anvil.mode = _MODE.NORMAL\n\n\ndef _reset_changes(buffered, drafts):\n    for row in buffered:\n        row._anvil.buffer.clear()\n\n    for row in drafts:\n        row._anvil.buffer.clear()\n\n\ndef save_all(*rows):\n    # TODO - only check this on the client\n    # but wait for auto batching to be implemented\n    # if not anvil.is_server_side() and batch_update.active:\n    if _batcher.batch_update.active:\n        raise RuntimeError(\"Cannot call save() inside a batch_update block\")\n\n    changes = {\n        \"rows\": [],\n        \"buffers\": [],\n        \"draft_info\": [],\n        \"single\": [],\n        \"multi\": [],\n    }\n    drafts = []\n    buffered = []\n    seen = {}\n\n    for row in rows:\n        _walk_buffered_changes(\n            row,\n            changes=changes,\n            drafts=drafts,\n            buffered=buffered,\n            seen=seen,\n        )\n\n    temp_buffers = [{**row._anvil.buffer} for row in buffered]\n    _reset_changes(buffered, [])\n    server_drafts = []\n\n    try:\n        if changes[\"draft_info\"] or changes[\"rows\"]:\n            if anvil.is_server_side():\n                server_drafts = _save_on_server(changes, False)\n            else:\n                from ._model import serialize_model\n\n                table_ids = {d[\"table_id\"] for d in changes[\"draft_info\"]}\n                models = [serialize_model(id, True) for id in table_ids]\n                server_drafts = anvil.server.call(\n                    \"anvil.tables.v2._save_on_server\", changes, models\n                )\n    except:\n        for row, buffer in zip(buffered, temp_buffers):\n            row._anvil.buffer.update(buffer)\n        raise\n\n    _initialize_drafts(server_drafts, drafts)\n    _reset_changes(buffered, drafts)\n\n\ndef reset_all(*rows):\n    changes = {\n        \"rows\": [],\n        \"buffers\": [],\n        \"draft_info\": [],  # {\"buffer\": dict, \"table_id\": str}[]\n        \"single\": [],  # {\"path\": [\"rows\" | \"drafts\", index, key], \"row\": int}\n        # the row row is where to find the draft in the draft list\n        # the path is the path to the hole that should be replaced by the draft row\n        \"multi\": [],  # {\"path\": [\"rows\" | \"drafts\", index, key], \"rows\": [Row | int]}\n        # the rows is a list of realized rows and ints\n        # the ints represent where to find the draft in the draft list\n        # the path is the path to the hole that should be replaced by the rows\n    }\n    drafts = []\n    seen = {}\n    buffered = []\n\n    for row in rows:\n        _walk_buffered_changes(\n            row,\n            changes=changes,\n            drafts=drafts,\n            buffered=buffered,\n            seen=seen,\n        )\n\n    _reset_changes(buffered, drafts)\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/v2\/_search.py"] = "import anvil.server\nfrom anvil.server import Capability\n\nfrom .._base_classes import SearchIterator as BaseSearchIterator\nfrom ._constants import CAP_KEY, SERVER_PREFIX, SHARED_DATA_KEY\nfrom ._row import Row\nfrom ._utils import (\n    check_serialized,\n    init_spec_rows,\n    init_view_data,\n    merge_row_data,\n    validate_cap,\n)\n\nPREFIX = SERVER_PREFIX + \"search.\"\n\n\nclass PartialSearchIter(object):\n    def __init__(self, s, slice_):\n        self._view_key = s._view_key\n        self._table_id = s._table_id\n        self._cap = s._cap\n        self._idx = slice_.start or 0\n        self._step = slice_.step or 1\n        self._stop = slice_.stop\n        row_ids, cap_next = s._row_ids, s._cap_next\n        if row_ids is None:\n            # this can happen in deserialization from untrusted\/None transmited data\n            row_ids, cap_next = [], s._cap\n        assert cap_next is None or type(cap_next) is Capability\n        self._reset(row_ids, cap_next, s._table_data)\n\n    def _reset(self, row_ids, cap_next, table_data):\n        if self._stop is not None and len(row_ids) > self._stop:\n            row_ids, cap_next = row_ids[: self._stop], None\n        self._row_ids = row_ids\n        self._cap_next = cap_next\n        self._table_data = table_data\n\n    def _iter_next_page(self):\n        if self._cap_next is None:\n            raise StopIteration\n\n        num_row_ids = len(self._row_ids)\n        self._idx -= num_row_ids\n        if self._stop is not None:\n            self._stop -= num_row_ids\n\n        row_ids, cap_next, table_data = anvil.server.call(\n            PREFIX + \"next_page\", self._cap_next\n        )\n\n        self._reset(row_ids, cap_next, table_data)\n        return self.__next__()\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        try:\n            row_id = self._row_ids[self._idx]\n        except IndexError:\n            return self._iter_next_page()\n        self._idx += self._step\n        return Row._anvil_create_from_trusted(\n            self._view_key, self._table_id, row_id, self._table_data\n        )\n\n    next = __next__\n\n\n@anvil.server.portable_class\nclass SearchIterator(BaseSearchIterator):\n    @classmethod\n    def _create(cls, view_key, table_id, row_ids, cap, cap_next, table_data):\n        self = object.__new__(cls)\n        assert cap_next is None or type(cap_next) is Capability\n        self._view_key = view_key\n        self._table_id = table_id\n        self._row_ids = row_ids\n        self._cap = cap\n        self._cap_next = cap_next\n        self._table_data = table_data\n        self._from_serialize = False\n        return self\n\n    @classmethod\n    def __new_deserialized__(cls, data, info):\n        view_key, table_id, row_ids, cap, cap_next = data\n        table_data, _ = info.shared_data(SHARED_DATA_KEY)\n        if not info.remote_is_trusted:\n            validate_cap(cap, table_id)\n            table_data = None\n        if not table_data:\n            row_ids = cap_next = None\n        # when we deserialize ourselves we may have more data than we need\n        self = cls._create(view_key, table_id, row_ids, cap, cap_next, table_data)\n        self._from_serialize = True\n        return self\n\n    def _fill_data(self):\n        self._row_ids, self._cap_next, self._table_data = anvil.server.call(\n            PREFIX + \"next_page\", self._cap\n        )\n\n    def _clear_cache(self):\n        self._row_ids = self._table_data = self._cap_next = None\n\n    # SERIALIZATION\n    def _make_row_data(self, row_data, table_spec, compact=True):\n        if type(row_data) is dict or compact:\n            # this row didn't match our cache_spec so just send it\n            # or we are list and we're compact because our cache_specs already match\n            return row_data\n\n        cache_spec = table_spec[\"cache\"]\n        # we are currently compact and we need to be a dict\n        new_data = {CAP_KEY: row_data[-1]}\n        iter_row_data = iter(row_data)\n\n        new_data = {\n            str(i): next(iter_row_data)\n            for i, is_cached in enumerate(cache_spec)\n            if is_cached\n        }\n        cap = next(iter_row_data)\n        assert type(cap is Capability)\n        new_data[CAP_KEY] = cap\n        return new_data\n\n    def _get_table_view_iter(self):\n        if not self._from_serialize:\n            # Fast Path - we were created from my_table.search() so the table_data is already minimal\n            # i.e. we don't need to clean it based on table_specs\n            return self._table_data.keys()\n\n        # Slow Path - we're reserializing ourselves from a previous serialization\n        # so we may have too much data if we were serialized with merged table_data\n        table_view_keys = set()\n        # walk the table_specs and insert the view_keys and table_ids we need\n        _populate_table_views_ids(self._view_key, self._table_data, table_view_keys)\n        return table_view_keys\n\n    def _merge(self, g_table_data, local_data):\n        if check_serialized(self, local_data):\n            return\n\n        table_view_keys = self._get_table_view_iter()\n\n        for view_key in table_view_keys:\n            g_view_data = init_view_data(view_key, g_table_data)\n            l_view_data = self._table_data[view_key]\n\n            l_table_spec, l_table_rows = (\n                l_view_data[\"spec\"],\n                l_view_data.get(\"rows\", {}),\n            )\n            g_table_spec, g_table_rows = init_spec_rows(g_view_data, l_table_spec)\n\n            g_cache_spec = g_table_spec[\"cache\"]\n            l_cache_spec = l_table_spec[\"cache\"]\n            cache_match = g_table_spec is l_table_spec or g_cache_spec == l_cache_spec\n\n            for row_id, row_data in l_table_rows.items():\n                if isinstance(row_data, Row):\n                    # Ok we've already been created\n                    # this is rare - we've consumed the search iterator and now we're serializing\n                    # or we created this row from shared serialization data and we're now reserializing\n                    row = row_data\n                    row._anvil_merge_and_reduce(g_table_data, local_data)\n                    continue\n\n                g_row_data = g_table_rows.get(row_id, [])\n                g_is_compact = cache_match and type(g_row_data) is list\n                row_data = self._make_row_data(\n                    row_data, l_table_spec, compact=g_is_compact\n                )\n                merge_row_data(\n                    row_id, row_data, g_table_rows, g_table_spec, l_cache_spec\n                )\n\n    def __serialize__(self, info):\n        table_data, local_data = info.shared_data(SHARED_DATA_KEY)\n        row_ids = self._row_ids\n        if table_data is None:\n            row_ids = self._cap_next = None\n        elif info.local_is_trusted and self._table_data is not None:\n            self._merge(table_data, local_data)\n        return [self._view_key, self._table_id, row_ids, self._cap, self._cap_next]\n\n    def _make_partial_iterator(self, slice_=slice(None)):\n        return PartialSearchIter(self, slice_)\n\n    def __iter__(self):\n        return self._make_partial_iterator()\n\n    def __len__(self):\n        if self._cap_next is None and self._row_ids is not None:\n            return len(self._row_ids)\n        return anvil.server.call(PREFIX + \"get_length\", self._cap)\n\n    def __hash__(self):\n        return hash((self._table_id, self._cap))\n\n    def __eq__(self, other):\n        if not isinstance(other, SearchIterator):\n            return NotImplemented\n        return self._cap == other._cap\n\n    def __bool__(self):\n        # because we have a __len__ and we can't suspend\n        return True\n\n    __nonzero__ = __bool__\n\n    def refresh(self):\n        self._clear_cache()\n\n    def to_csv(self, escape_for_excel=False):\n        return anvil.server.call(\n            PREFIX + \"to_csv\", self._cap, escape_for_excel=escape_for_excel\n        )\n\n    def delete_all_rows(self):\n        result = anvil.server.call(PREFIX + \"delete_all\", self._cap)\n        self._clear_cache()\n        return result\n\n    def __getitem__(self, idx):\n        if self._row_ids is None:\n            self._fill_data()\n\n        if isinstance(idx, slice):\n            slice_ = slice(\n                as_slice_idx(idx.start), as_slice_idx(idx.stop), as_slice_idx(idx.step)\n            )\n            return self._make_partial_iterator(slice_)\n        else:\n            slice_ = slice(as_idx(idx), None)\n        try:\n            return next(self._make_partial_iterator(slice_))\n        except StopIteration:\n            raise IndexError(\"search index out of range\")\n\n\ndef as_idx(i, msg=\"search indices must be non-negative integers\", can_be_none=False):\n    if i is None and can_be_none:\n        return None\n    elif type(i) is int:\n        pass\n    elif hasattr(i, \"__index__\"):\n        i = i.__index__()\n    else:\n        raise TypeError(msg)\n    if i < 0:\n        raise ValueError(msg)\n    return i\n\n\ndef as_slice_idx(i):\n    msg = \"search slice indices must non-negative itegers (or None)\"\n    return as_idx(i, msg, True)\n\n\ndef _populate_table_views_ids(view_key, table_data, seen):\n    # We might hold too much data if our table_data was from another serialization\n    # If we're reserializing ourselves then this method prevents sending unnecessary data across the wire\n    if view_key in seen:\n        # prevent circular references\n        return\n\n    try:\n        table_spec = table_data[view_key][\"spec\"]\n    except KeyError:\n        # Then these linked rows were not included in the data - probably uncached from the cache spec\n        # don't try include this view_key when serializing the data\n        return\n\n    seen.add(view_key)\n    cols = table_spec[\"cols\"]\n\n    for col in cols:\n        view_key = col.get(\"view_key\")\n        if view_key is None:\n            continue\n        _populate_table_views_ids(view_key, table_data, seen)\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/v2\/_table.py"] = "import anvil.server\nfrom anvil.server import Capability\n\nfrom .._base_classes import Table as BaseTable\nfrom ._constants import CASCADE, KNOWN_PERMS, READ, SERVER_PREFIX, WRITE\nfrom ._model import get_base_model_cls\nfrom ._refs import make_refs\nfrom ._row import Row\nfrom ._search import SearchIterator\nfrom ._utils import validate_cap\n\nPREFIX = SERVER_PREFIX + \"table.\"\n\n\n@anvil.server.portable_class\nclass Table(BaseTable):\n    @classmethod\n    def _create(cls, cap, view_key, table_id):\n        assert cap is None or type(cap) is Capability, \"expected a table capability\"\n        self = object.__new__(cls)\n        self._cap = cap\n        self._view_key = view_key\n        table_id = str(table_id)\n        self._id = table_id\n        self.Row = get_base_model_cls(table_id)\n        return self\n\n    @classmethod\n    def __new_deserialized__(cls, data, info):\n        cap, view_key, table_id = data\n        if not info.remote_is_trusted:\n            validate_cap(cap, table_id)\n        return cls._create(cap, view_key, table_id)\n\n    def __serialize__(self, _info):\n        return [self._cap, self._view_key, self._id]\n\n    def __iter__(self):\n        raise TypeError(\n            \"You can't iterate on a table. Call search() on this table to get an iterator of rows instead.\"\n        )\n\n    def __eq__(self, other):\n        if not isinstance(other, Table):\n            return NotImplemented\n        return other._id == self._id\n\n    def __hash__(self):\n        return hash(self._id)\n\n    def __contains__(self, row):\n        return self.has_row(row)\n\n    def _get_view(self, perm, args, kws):\n        assert perm in KNOWN_PERMS, \"bad permission\"\n        new_cap, view_key = anvil.server.call(\n            PREFIX + \"get_view\", self._cap, perm, None, make_refs(args), make_refs(kws)\n        )\n        return Table._create(new_cap, view_key, self._id)\n\n    # PUBLIC API\n    def restrict_columns(self, col_spec):\n        new_cap, view_key = anvil.server.call(\n            \"get_restricted_columns\", self._cap, col_spec\n        )\n        return Table._create(new_cap, view_key, self._id)\n\n    def client_readable(self, *args, **kws):\n        return self._get_view(READ, args, kws)\n\n    def client_writable(self, *args, **kws):\n        return self._get_view(WRITE, args, kws)\n\n    def client_writable_cascade(self, *args, **kws):\n        return self._get_view(CASCADE, args, kws)\n\n    def delete_all_rows(self):\n        return anvil.server.call(PREFIX + \"delete_all_rows\", self._cap)\n\n    def add_rows(self, rows):\n        # rows can be an iterable of dicts\n        row_dicts = []\n        refs = []\n        for row in rows:\n            row = dict(row)\n            refs.append(make_refs(row))\n            row_dicts.append(row)\n        row_id_caps, spec = anvil.server.call(PREFIX + \"add_rows\", self._cap, refs)\n        return [\n            self.Row._anvil_create_from_local_values(\n                self._view_key, self._id, row_id, spec, cap, row_items\n            )\n            for (row_id, cap), row_items in zip(row_id_caps, row_dicts)\n        ]\n\n    def add_row(self, **data):\n        return self._do_add_row(data)\n\n    def _do_add_row(self, data, on_behalf_of_client=False):\n        row_id, cap, spec = anvil.server.call(\n            PREFIX + \"add_row\", self._cap, make_refs(data), on_behalf_of_client\n        )\n        return self.Row._anvil_create_from_local_values(\n            self._view_key, self._id, row_id, spec, cap, data\n        )\n\n    def get(self, *args, **kws):\n        row_id_table_data = anvil.server.call(\n            PREFIX + \"get_row\", self._cap, make_refs(args), make_refs(kws)\n        )\n        return row_id_table_data and self.Row._anvil_create_from_trusted(\n            self._view_key, self._id, *row_id_table_data\n        )\n\n    def get_by_id(self, row_id, fetch=None):\n        row_id_table_data = anvil.server.call(\n            PREFIX + \"get_row_by_id\", self._cap, row_id, fetch=fetch\n        )\n        return row_id_table_data and self.Row._anvil_create_from_trusted(\n            self._view_key, self._id, *row_id_table_data\n        )\n\n    def has_row(self, row):\n        if not isinstance(row, Row):\n            # backwards compatability return False\n            return False\n        elif row._anvil.table_id != self._id:\n            return False\n        return anvil.server.call(PREFIX + \"has_row\", self._cap, row._anvil.id)\n\n    def list_columns(self):\n        return anvil.server.call(PREFIX + \"list_columns\", self._cap)\n\n    def search(self, *args, **kws):\n        kws = make_refs(kws)\n        row_ids, cap, cap_next, table_data = anvil.server.call(\n            PREFIX + \"search\", self._cap, args, kws\n        )\n        return SearchIterator._create(\n            self._view_key, self._id, row_ids, cap, cap_next, table_data\n        )\n\n    def to_csv(self, escape_for_excel=False):\n        return anvil.server.call(\n            PREFIX + \"to_csv\", self._cap, escape_for_excel=escape_for_excel\n        )\n\n    # TODO reinclude this API\n    # @property\n    # def id(self):\n    #     return self._id\n";Sk.builtinFiles.files["anvil-services\/anvil\/tables\/v2\/_utils.py"] = "import anvil\nimport anvil.tz\nfrom anvil.server import Capability, unwrap_capability\n\nfrom ._constants import CAP_KEY, NOT_FOUND, UNCACHED\n\n\nclass InternalDict:\n    pass\n\n\nThreadLocal = object\n\nif anvil.is_server_side():\n    try:\n        from anvil._threaded_server import ThreadLocal\n    except ImportError:\n        pass\n\n\ndef validate_cap(cap, table_id, row_id=NOT_FOUND):\n    # this function ensures that the cap is the right shape and references the right table\/row\n    # full validation happens in clojure\n    _, _, view_dict, narrowed, _ = unwrap_capability(\n        cap, [\"_\", \"t\", Capability.ANY, Capability.ANY, Capability.ANY]\n    )\n    assert str(view_dict[\"id\"]) == table_id\n    if row_id is not NOT_FOUND:\n        assert row_id == str(narrowed[\"r\"])\n\n\ndef clean_local_datetime(d):\n    if d.tzinfo is not None:\n        offset = d.utcoffset().total_seconds()\n    else:\n        offset = anvil.tz.tzlocal().utcoffset(d).total_seconds()\n    return d.replace(tzinfo=anvil.tz.tzoffset(seconds=offset))\n\n\n# Serialization helpers\ndef check_serialized(self, local_data):\n    self_id = id(self)\n    serialized = local_data.get(self_id, False)\n    local_data[self_id] = True\n    return serialized\n\n\ndef init_view_data(view_key, g_table_data):\n    return g_table_data.setdefault(view_key, {})\n\n\ndef init_spec_rows(g_view_data, table_spec, cache_spec=None):\n    g_table_spec = g_view_data.get(\"spec\")\n    if g_table_spec is not None:\n        pass\n    elif table_spec is None or cache_spec is None:\n        g_table_spec = g_view_data[\"spec\"] = table_spec\n    else:\n        g_table_spec = g_view_data[\"spec\"] = {\n            \"cols\": table_spec[\"cols\"],\n            \"cache\": cache_spec,\n        }\n    g_table_rows = g_view_data.setdefault(\"rows\", {})\n    return g_table_spec, g_table_rows\n\n\ndef merge_row_data(row_id, row_data, g_table_rows, g_table_spec, row_cache_spec):\n    # we've already cleaned the row_data\n    #  - it will only be a compact list if the caches match\n    #  - and g_row_data is either None or also a compact list\n    # otherwise row_data will be a dict\n    g_row_data = g_table_rows.get(row_id)\n\n    # FAST - common case - nothing in row_data\n    if g_row_data is None:\n        g_table_rows[row_id] = row_data\n        return\n\n    g_row_type = type(g_row_data)\n    row_type = type(row_data)\n\n    # handle all UNCACHED - i.e. the partially cached writer wins\n    if g_row_type is list and len(g_row_data) == 1:\n        # the row serialized before us has an all 0 cache_spec and is compact\n        # we are either a dict or a list of the same length\n        g_table_rows[row_id] = row_data\n        return\n    if not any(row_cache_spec):\n        # the row to merge has an all 0 cache_spec\n        return\n\n    # SLOW PATH - uncommon cases\n    # Another reference to this row (not the exact same row) was already serialized before us\n    if row_type is list:\n        # g_row_data must also be a compact list if row_data is a list\n        # they must have the same length at this stage since we know the cache specs match\n        if g_row_type is list:\n            # fail safe sanity check\n            merge_compact(row_data, g_row_data)\n\n    elif g_row_type is dict:\n        # then the previously serialized reference to this row\n        # didn't match the g_cache_spec\n        # so just take the itersect of the dictionaries\n        g_table_rows[row_id] = merge_dicts(row_data, g_row_data)\n        return\n    else:\n        # finally the g_row_type is a compact list and we are a dict - make it a dict\n        g_cache_spec = g_table_spec[\"cache\"]\n        merge_dict_with_compact(row_data, g_row_data, row_cache_spec, g_cache_spec)\n        g_table_rows[row_id] = row_data\n\n\ndef merge_compact(row_data, g_row_data):\n    # any conflicts just replace with UNCACHED sentinel\n    # use len - 1 so we skip the Capability\n    for i in range(len(row_data) - 1):\n        gbl, loc = g_row_data[i], row_data[i]\n        if gbl != loc:\n            g_row_data[i] = UNCACHED\n\n\ndef merge_dicts(row_data, g_row_data):\n    # walk the smallest\n    merged = {}\n    a, b = (\n        (row_data, g_row_data)\n        if len(row_data) < len(g_row_data)\n        else (g_row_data, row_data)\n    )\n    cap = a.pop(CAP_KEY)\n    for key, a_val in a.items():\n        b_val = b.get(key, NOT_FOUND)\n        if a_val == b_val:\n            merged[key] = a_val\n    merged[CAP_KEY] = a[CAP_KEY] = cap\n    return a\n\n\ndef merge_dict_with_compact(row_data, g_row_data, row_cache_spec, g_cache_spec):\n    iter_g_row_data = iter(g_row_data)\n    for i, (is_cached, g_is_cached) in enumerate(zip(row_cache_spec, g_cache_spec)):\n        i = str(i)\n        if not g_is_cached:\n            # we could use the incoming caller wins here\n            if is_cached:\n                row_data.pop(i, None)\n            continue\n\n        g_val = next(iter_g_row_data)\n        if not is_cached:\n            continue\n\n        if i in row_data and row_data[i] != g_val:\n            row_data.pop(i)\n\n    return row_data\n";Sk.builtinFiles.files["anvil-services\/anvil\/email.py"] = "import anvil.server\n\n#!defModule(anvil.email)!1: \"The `anvil.email` module contains functions for sending and receiving email in your Anvil app.\"\n\n#!suggestAttr(anvil.email,send)!0:\n\n#!defClass(anvil.email,SendFailure)!:\nclass SendFailure(anvil.server.AnvilWrappedError):\n    pass\n\nanvil.server._register_exception_type(\"anvil.email.SendFailure\", SendFailure)\n\nclass DeliveryFailure(Exception):\n    #!defMethod(_,message=None,smtp_code=554)!2: \n    # {anvil$helpLink: \"\/docs\/email\/sending_and_receiving#rejecting-email\", $doc: \"While handling an error, you can raise a DeliveryFailure exception to reject email delivery. Optionally, you may specify a message and SMTP error code with the rejection.\"} [\"__init__\"]\n    def __init__(self, message=None, smtp_code=None):\n        if message is None:\n            super(DeliveryFailure, self).__init__()\n        elif smtp_code is not None:\n            message = \"{}: {}\".format(smtp_code, message)\n        super(DeliveryFailure, self).__init__(message)\n    #!defClass(anvil.email,DeliveryFailure)!:\n\n\n\n#!defFunction(anvil.email,anvil.email.SendReport instance,[to=],[cc=],[bcc=],[from_address=\"no-reply\"],[from_name=],[subject=],[text=],[html=],[attachments=],[inline_attachments=])!2:\n# {\n#   $doc: \"Send an email\",\n#   anvil$helpLink: \"\/docs\/email\",\n#   anvil$args: {\n#     to: \"The email recipient[s] in the 'To' field. Can be a string or list of strings.\\n\\nEach string can be a bare address (eg 'joe@example.com') or include a display name (eg 'Joe Bloggs <joe@example.com>').\",\n#     cc: \"The email recipient[s] in the 'Cc' field. Can be a string or list of strings.\\n\\nEach string can be a bare address (eg 'joe@example.com') or include a display name (eg 'Joe Bloggs <joe@example.com>').\",\n#     bcc: \"The email recipient[s] in the 'Bcc' field. Can be a string or list of strings.\\n\\nEach string can be a bare address (eg 'joe@example.com') or include a display name (eg 'Joe Bloggs <joe@example.com>').\",\n#     from_address: \"The From: address from this email. Can be a bare address (eg 'joe@example.com') or include a display name (eg 'Joe Bloggs <joe@example.com>').\\n\\nIf no domain is specified, or the specified domain is not a legal sending domain for this app, the address will be replaced with a valid domain. So if you specify 'noreply', the email will come from 'noreply@your-app-domain.anvil.app'.\",\n#     from_name: \"The name associated with the From: address for this email. (Only valid if the from_address is a bare email address.)\",\n#     subject: \"The subject line for this email.\",\n#     text: \"The plain-text (no HTML) content for this email. You must specify at least one of 'text' and 'html'.\",\n#     html: \"The HTML content for this email. You must specify at least one of 'text' and 'html'.\",\n#     attachments: \"A list of Media objects to send as attachments with this email.\",\n#     inline_attachments: \"Inline that can be used in this email's HTML, for example in <img> tags. Must be a dictionary whose keys are IDs and values are Media objects. IDs can then be used in a message's HTML with 'cid:xxx' URIs.\",\n#   }\n# } [\"send\"]\ndef send(**kw):\n    return anvil.server.call(\"anvil.private.email.send.v2\", **kw)\n\n# NB no defFunction() here; this one is defined in the autocompleter\ndef handle_message(fn=None, require_dkim=False):\n    def wrapper(fn):\n        import functools # don't try to import this on the client\n        @functools.wraps(fn)\n        def handler(msg_dict):\n            msg = Message(msg_dict)\n            if require_dkim and not msg.dkim.valid_from_sender:\n                raise DeliveryFailure(\"No valid DKIM signature for %s\" % msg.envelope.from_address)\n            fn(msg)\n        return anvil.server.callable(\"email:handle_message\")(handler)\n    return wrapper(fn) if fn is not None else wrapper\n\n\n@anvil.server.portable_class\nclass Address(object):\n\n    #!defAttr()!1: {name:\"address\",type:\"string\",description:\"The email address this object represents.\"}\n    #!defAttr()!1: {name:\"name\",type:\"string\",description:\"The name associated with the address this object represents.\"}\n    #!defAttr()!1: {name:\"raw_value\",type:\"string\",description:\"The full string value of this address.\"}\n    def __init__(self, address):\n        self.address = address['address']\n        self.name = address['name']\n        self.raw_value = address['raw']\n\n    #!defClass(anvil.email,#Address)!:\n\n\n@anvil.server.portable_class\nclass Message(object):\n    #!defAttr()!1: {name:\"from_address\",type:\"string\",description:\"The email address from which this message was sent, according to the SMTP envelope.\"}\n    #!defAttr()!1: {name:\"recipient\",type:\"string\",description:\"The email address that received this message.\\n\\nNote that this email address may not appear in any of the headers (eg if the email has been BCCed or blind forwarded).\"}\n    @anvil.server.portable_class\n    class Envelope(object):\n        def __init__(self, envelope):\n            self.from_address = envelope['from']\n            self.recipient = envelope['recipient']\n    #!defClass(anvil.email.Message,#Envelope)!:\n\n    #!defAttr()!1: {name:\"valid_from_sender\",type:\"boolean\",description:\"Was this message signed by the domain in its envelope \\\"from\\\" address?\"}\n    #!defAttr()!1: {name:\"domains\",type:\"list(string)\",description:\"A list of the DKIM domains that signed this message.\"}\n    @anvil.server.portable_class\n    class DKIM(object):\n        def __init__(self, dkim):\n            self.valid_from_sender = dkim['valid_from_sender']\n            self.domains = dkim['domains']\n    #!defClass(anvil.email.Message,#DKIM)!:\n\n\n    #!defAttr()!1: {name:\"to_addresses\",pyType:\"list(anvil.email.Address instance)\",description:\"The addresses this message was sent to.\"}\n    #!defAttr()!1: {name:\"from_address\",pyType:\"anvil.email.Address instance\",description:\"The address this message was sent from.\"}\n    #!defAttr()!1: {name:\"cc_addresses\",pyType:\"list(anvil.email.Address instance)\",description:\"The addresses this message was copied to.\"}\n    @anvil.server.portable_class\n    class Addressees(object):\n        def __init__(self, addressees):\n            self.to_addresses = [Address(a) for a in addressees.get('to',[])]\n            self.from_address = Address(addressees['from'][0]) if 'from' in addressees else None\n            self.cc_addresses = [Address(a) for a in addressees.get('cc',[])]\n    #!defClass(anvil.email.Message,#Addressees)!:\n\n\n    #!defAttr()!1: {name:\"envelope\",pyType:\"anvil.email.Message.Envelope instance\",description:\"The sender and receipient of this email, according to the SMTP envelope.\"}\n    #!defAttr()!1: {name:\"dkim\",pyType:\"anvil.email.Message.DKIM instance\",description:\"Object describing whether this message was signed by the sending domain\"}\n    #!defAttr()!1: {name:\"addressees\",pyType:\"anvil.email.Message.Addressees instance\",description:\"The addresses this email was sent from and to, according to the headers.\"}\n    #!defAttr()!1: {name:\"headers\",type:\"list\",description:\"All the headers in this email, as a list of (name,value) pairs.\"}\n    #!defAttr()!1: {name:\"text\",type:\"string\",description:\"The plain-text content of this email, or None if there is no plain-text part.\"}\n    #!defAttr()!1: {name:\"subject\",type:\"string\",description:\"The subject of this email, or None if there is no subject.\"}\n    #!defAttr()!1: {name:\"html\",type:\"string\",description:\"The HTML content of this email, or None if there is no HTML part.\"}\n    #!defAttr()!1: {name:\"attachments\",pyType:\"list(anvil.Media instance)\",description:\"A list of this email's attachments.\"}\n    #!defAttr()!1: {name:\"inline_attachments\",pyType:\"dict(string,anvil.Media instance)\",description:\"A dictionary of this email's inline attachments. Keys are ContentID headers, values are the attachments as Media Objects.\"}\n\n    def __init__(self, msg_dict):\n        self.envelope = Message.Envelope(msg_dict['envelope'])\n        self.dkim = Message.DKIM(msg_dict['dkim'])\n        self.addressees = Message.Addressees(msg_dict['addressees'])\n        self.headers = msg_dict['headers']\n        self.subject = msg_dict['subject']\n        self.text = msg_dict['text']\n        self.html = msg_dict['html']\n        self.attachments = msg_dict['attachments']\n        self.inline_attachments = msg_dict['inline_attachments']\n\n    #!defMethod(_,header_name,[default=None])!2: \"Return the value of the specified header, or default value if it is not present.\\n\\nCase-insensitive. If the header is specified multiple times, returns the first value.\" [\"get_header\"]\n    def get_header(self, header_name, default=None):\n        header_name = header_name.lower()\n        for name,value in self.headers:\n            if name.lower() == header_name:\n                return value\n        return default\n\n    #!defMethod(_,header_name)!2: \"Return a list containing every value of the specified header. Case-insensitive.\" [\"list_header\"]\n    def list_header(self, header_name):\n        header_name = header_name.lower()\n        return [value for name,value in self.headers\n                if name.lower() == header_name]\n\n    #!defMethod(_,[cc=],[bcc=],[from_address=],[from_name=],[text=],[html=],[attachments=])!2: \"Reply to this email.\" [\"reply\"]\n    def reply(self,**kw):\n        kw['to'] = kw.get('to', self.get_header(\"Reply-To\", None))\n        if kw['to'] is None:\n            if self.addressees.from_address is not None:\n                kw['to'] = self.addressees.from_address.raw_value\n            else:\n                kw['to'] = self.envelope.from_address\n        if kw['to'] is None:\n            raise Exception(\"Cannot reply to a message with no Reply-To header, From address, or Envelope From address.\")\n\n        kw['subject'] = kw.get('subject', self.subject)\n        kw['in_reply_to'] = self.get_header(\"Message-ID\")\n        if kw['in_reply_to']:\n            kw['references'] = self.get_header(\"References\", \"\") + \" \" + kw['in_reply_to']\n        kw['from_address'] = kw.get('from_address', self.envelope.recipient)\n        send(**kw)\n\n    def __str__(self):\n\n        truncated_text = \"\"\n        if self.text:\n            truncated_text = self.text.replace(\"\\n\", \" \\\\ \")\n            (truncated_text[:70] + '...') if len(truncated_text) > 70 else truncated_text,\n\n        return \"\"\"anvil.email.Message:\n    from: %s\n    to: %s\n    subject: %s\n    text: %s\n    attachments: %s\"\"\" % (\n            self.addressees.from_address and self.addressees.from_address.raw_value,\n            len(self.addressees.to_addresses) > 0 and self.addressees.to_addresses[0].raw_value,\n            self.subject,\n            truncated_text,\n            \", \".join([\"%s (%s bytes)\" % (a.name, len(a.get_bytes())) for a in self.attachments]) if len(self.attachments) > 0 else None\n        )\n\n    #!defClass(anvil.email,#Message)!:\n\n\n@anvil.server.portable_class\nclass SendReport(object):\n\n    #!defAttr()!1: {name: \"message_id\", type: \"string\", description: \"The Message-ID header given to this outgoing message.\"}\n\n    def __init__(self):\n        raise Exception(\"Cannot construct a SendReport manually\")\n\n    #!defClass(anvil.email,#SendReport)!:\n";const loadApp = window.loadApp({"app":{"allow_embedding":false,"dependency_code":{},"package_name":"_MLB_MOMENTS_ERICKSALAS","config":{"client":{}},"modules":[],"name":" MLB MOMENTS ERICKSALAS","dependency_ids":{},"startup_form":"HomeForm","dependency_order":[],"theme":{"html":{"standard-page.html":"<link href=\"https:\/\/fonts.googleapis.com\/css?family=Roboto:300,400,500\" rel=\"stylesheet\">\n\n<div class=\"structure\">\n  <div class=\"app-bar\" anvil-drop-container=\".anvil-container\" anvil-drop-redirect=\".placeholder\">\n    <a class=\"sidebar-toggle\" anvil-if-slot-empty=\"top-left-btn\" anvil-hide-if-slot-empty=\"left-nav\" anvil-drop-slot=\"top-left-btn\" href=\"javascript:void(0)\"><i class=\"fa fa-bars\"><\/i><\/a>\n    <a class=\"sidebar-toggle anvil-designer-only\" anvil-if-slot-empty=\"top-left-btn\" anvil-if-slot-empty=\"left-nav\" anvil-drop-slot=\"top-left-btn\"><i class=\"fa fa-blank\"><\/i><\/a>\n    <div class=\"top-left-btn\" anvil-slot=\"top-left-btn\"><\/div>\n    <div class=\"title\" anvil-slot=\"title\">\n      <div class=\"placeholder anvil-designer-only\" anvil-if-slot-empty=\"title\" anvil-drop-here>Drop title here<\/div>\n    <\/div>\n    <div class=\"app-bar-nav\" anvil-slot=\"nav-right\">\n      <div class=\"placeholder anvil-designer-only\" anvil-if-slot-empty=\"nav-right\" anvil-drop-here>Drop a FlowPanel here<\/div>\n    <\/div>\n    <div style=\"clear:both\"><\/div>\n  <\/div>\n\n  <div class=\"nav-holder\">\n    <div class=\"left-nav anvil-measure-this\" anvil-slot-repeat=\"left-nav\" anvil-drop-container=\">.anvil-container\">\n    <\/div>\n    <div class=\"left-nav-placeholder anvil-designer-only\" anvil-if-slot-empty=\"left-nav\" anvil-drop-slot=\"left-nav\">\n      <div class=\"prompt\">To add a sidebar, drop a ColumnPanel here.<\/div>\n    <\/div>\n\n    <div class=\"content\">\n      <div anvil-slot-repeat=\"default\" class=\"anvil-measure-this\"><\/div>\n      <div class=\"placeholder drop-here\" anvil-if-slot-empty=\"default\" anvil-drop-slot=\"default\">Drop a ColumnPanel here.<\/div>\n    <\/div>\n  <\/div>\n  <div class=\"nav-shield\"><\/div>\n<\/div>\n<div anvil-drop-default anvil-drop-redirect=\".placeholder\" anvil-drop-container=\".anvil-container\"><\/div>\n \n<script>\n  function hideSidebar() {\n    var ln = $('.structure > .nav-holder > .left-nav');\n    ln.animate({left: -ln.outerWidth()}, function() {\n      ln.removeClass(\"in-transition shown\").addClass(\"hidden\");\n    $('.nav-shield').removeClass(\"shown\");\n    });\n  }\n  function showSidebar() {\n    var ln = $('.structure > .nav-holder > .left-nav');\n    $('.nav-shield').addClass(\"shown\");\n    ln.addClass(\"shown\").removeClass(\"hidden\").css({left: \"-100%\"}).css({left: -ln.outerWidth()}).animate({left: 0}, function() {\n      ln.removeClass(\"in-transition\");\n    });\n  }\n  $('.sidebar-toggle, .nav-shield').off('click').on('click', function() {\n    var ln = $('.structure > .nav-holder > .left-nav');\n    if (ln.is(\":visible\") || $('.nav-shield').is(\".shown\")) {\n      hideSidebar();\n    } else if(!ln.is(\":empty\")) {\n      showSidebar();\n    }\n  });\n  $('.left-nav').off('click').on('click', 'a, button', function() {\n    if ($('.nav-shield').is(\":visible\")) {\n      $('.nav-shield').trigger('click');\n    }\n  });\n<\/script>"},"color_scheme":{"Primary 700":"#1976D2","Black":"#000000","Secondary 500":"#FF9800","Gray 900":"#212121","Gray 100":"#F5F5F5","Gray 300":"#E0E0E0","Gray 800":"#424242","White":"#FFFFFF","Gray 200":"#EEEEEE","Gray 600":"#757575","Primary 500":"#2196F3","Secondary 700":"#F57C00","Gray 50":"#FAFAFA"},"vars":{"Primary 700":"--anvil-color-Primary-700-8e45","Black":"--anvil-color-Black-df88","Secondary 500":"--anvil-color-Secondary-500-5364","Gray 900":"--anvil-color-Gray-900-6590","Gray 100":"--anvil-color-Gray-100-ebfa","Gray 300":"--anvil-color-Gray-300-9dda","Gray 800":"--anvil-color-Gray-800-54c7","White":"--anvil-color-White-beae","Gray 200":"--anvil-color-Gray-200-9626","Gray 600":"--anvil-color-Gray-600-f264","Primary 500":"--anvil-color-Primary-500-268b","Secondary 700":"--anvil-color-Secondary-700-4270","Gray 50":"--anvil-color-Gray-50-1a61"}},"runtime_options":{"version":2,"client_version":"3"},"forms":[{"components":[{"components":[{"components":[{"layout_properties":{"grid_position":"IEVAXK,QCCFZP"},"name":"label_1","properties":{"role":"headline","bold":true,"align":"left","spacing_above":"small","background":"","icon":"","underline":false,"font":"","icon_align":"left","foreground":"","spacing_below":"small","visible":true,"border":"","italic":false,"font_size":null,"tooltip":"","text":"Feedback Form"},"type":"Label"},{"layout_properties":{"grid_position":"ROOKHV,WBMCVD"},"name":"label_2","properties":{"role":null,"bold":false,"align":"left","spacing_above":"small","background":"","icon":"","underline":false,"font":"","icon_align":"left","foreground":"","spacing_below":"small","visible":true,"border":"","italic":false,"font_size":null,"tooltip":"","text":"Name:"},"type":"Label"},{"layout_properties":{"grid_position":"ROOKHV,CPYUWC"},"name":"name_box","properties":{},"type":"TextBox"},{"layout_properties":{"grid_position":"ICXUVK,HQIARV"},"name":"label_3","properties":{"role":null,"bold":false,"align":"left","spacing_above":"small","background":"","icon":"","underline":false,"font":"","icon_align":"left","foreground":"","spacing_below":"small","visible":true,"border":"","italic":false,"font_size":null,"tooltip":"","text":"Email:"},"type":"Label"},{"layout_properties":{"grid_position":"ICXUVK,WWAASA"},"name":"email_box","properties":{},"type":"TextBox"},{"layout_properties":{"grid_position":"MBANSN,DSAPWS"},"name":"label_4","properties":{"role":null,"bold":false,"align":"left","spacing_above":"small","background":"","icon":"","underline":false,"font":"","icon_align":"left","foreground":"","spacing_below":"small","visible":true,"border":"","italic":false,"font_size":null,"tooltip":"","text":"Feedback:"},"type":"Label"},{"layout_properties":{"grid_position":"VBRMEF,GFZMQR"},"name":"feedback_box","properties":{},"type":"TextArea"},{"event_bindings":{"click":"submit_button_click"},"layout_properties":{"grid_position":"MHBKKL,GWGQWM"},"name":"submit_button","properties":{"role":"primary-color","bold":false,"align":"center","spacing_above":"small","background":"","icon":"","underline":false,"font":"","icon_align":"left","foreground":"","spacing_below":"small","visible":true,"border":"","italic":false,"enabled":true,"font_size":null,"tooltip":"","text":"Submit"},"type":"Button"}],"layout_properties":{"grid_position":"OGJZJD,CMXRPA"},"name":"card_1","properties":{"col_widths":"{}","role":"card"},"type":"ColumnPanel"},{"layout_properties":{"grid_position":"CUSAQI,LVACLQ"},"name":"sample_app_description","properties":{"role":"sample-app-info","format":"markdown","align":"left","spacing_above":"small","content":"#### Hi there!\n\nThis is Anvil's **drag-and-drop designer**. Click on a component to select it and edit its properties, or drag and drop a new component from the toolbox.\n\n**This app is ready to run!** If you enter some feedback and click \"submit\", you'll receive an email. To try it out, click ![Run](_\/theme\/run-button.png) up at the top.\n\nTo see the **Python code** for this form, double-click the `SUBMIT` button, or select ![code](_\/theme\/code-button.png) in the toolbar above.\n\nWant more help? Check out the tutorials on the Anvil website!","background":"","font":"","foreground":"","spacing_below":"small","visible":true,"border":"","enable_slots":true,"font_size":null,"tooltip":"","data":null},"type":"RichText"}],"layout_properties":{"slot":"default"},"name":"content_panel","properties":{"col_widths":"{}"},"type":"ColumnPanel"},{"layout_properties":{"slot":"nav-right"},"name":"navbar_links","properties":{},"type":"FlowPanel"},{"layout_properties":{"slot":"title"},"name":"title_lbl","properties":{"text":"Feedback"},"type":"Label"}],"container":{"properties":{"html":"@theme:standard-page.html"},"type":"HtmlTemplate"},"is_package":true,"code":"import anvil.tables as tables\nimport anvil.tables.query as q\nfrom anvil.tables import app_tables\n import anvil.http\nimport  as pd  # Correct import for pandas\n\n\n# ... (rest of the code from the Colab notebook) ...\n\n# Assuming 'pitching_stats' DataFrame is already loaded as in the previous code.\n\ndef get_player_stats(player_id):\n    \"\"\"\n    Retrieves pitching statistics for a given player ID.\n\n    Args:\n        player_id: The ID of the player.\n\n    Returns:\n        A pandas DataFrame containing the player's pitching statistics,\n        or None if the player is not found.\n    \"\"\"\n    try:\n        player_id = int(player_id)  # Ensure player_id is an integer\n        player_stats = pitching_stats[pitching_stats[\"player_id\"] == player_id]\n        if not player_stats.empty:\n            return player_stats\n        else:\n          return None\n    except (ValueError, KeyError):\n        return None\n\n# Example usage\nplayer_id_to_lookup = 605141  # Example player ID (replace with desired ID)\nplayer_stats_result = get_player_stats(player_id_to_lookup)\n\nif player_stats_result is not None:\n  print(player_stats_result)\nelse:\n  print(f\"No stats found for player ID: {player_id_to_lookup}\")\n#\n# This is the Python code that makes this feedback form work.\n# It's a Python class, with a method that runs when the user\n# clicks the SUBMIT button.\n#\n# When the button is clicked, we send the contents of the\n# text boxes to our Server Module. The Server Module records\n# the feedback in the database, and sends an email to the\n# app's owner (that's you!).\n#\n# To find the Server Module, look under \"Server Code\" on the\n# left.\n#\n\n\nclass HomeForm(HomeFormTemplate):\n  def __init__(self, **properties):\n    # Set Form properties and Data Bindings.\n    self.init_components(**properties)\n\n    # Any code you write here will run when the form opens.\n\n  def submit_button_click(self, **event_args):\n    # This method runs when the button is clicked.\n    # First, we grab the contents of the text boxes:\n    name = self.name_box.text\n    email = self.email_box.text\n    feedback = self.feedback_box.text\n\n    # Now we call our Server Module to save our input\n    # in the database and send you an email:\n    anvil.server.call(\"add_feedback\", name, email, feedback)\n    # (Hint: Find ServerModule1 under \"Server Code\" on the\n    # left. Click on the folder icon if you can't see it.)\n\n    # Display something to the user so they know it worked:\n    Notification(\"Feedback submitted!\").show()\n    self.clear_inputs()\n\n  def clear_inputs(self):\n    self.name_box.text = \"\"\n    self.email_box.text = \"\"\n    self.feedback_box.text = \"\"\n","class_name":"HomeForm","id":"RXKECMZN34MQAHDRK6EPIICDWR6S3KGX"}],"services":[{"source":"\/runtime\/services\/tables.yml","client_config":{}},{"source":"\/runtime\/services\/anvil\/email.yml","client_config":{}}]},"appId":"KSKWODC3NEPJKJPD","appOrigin":"https:\/\/kskwodc3nepjkjpd.anvil.app\/PJOKXTGSOMCUER3YFCIEKC7R","appStartupData":null,"ideOrigin":"https:\/\/anvil.works","runtimeVersion":3,"isCrawler":null});const loadAppAfter = window.anvil._loadAppAfter || [];loadApp.then(function() { Promise.all(loadAppAfter).then(function() {window.openForm("HomeForm");});});});
</script>


</body></html>
import  as pd  # Correct import for pandas


# ... (rest of the code from the Colab notebook) ...

# Assuming 'pitching_stats' DataFrame is already loaded as in the previous code.

def get_player_stats(player_id):
    """
    Retrieves pitching statistics for a given player ID.

    Args:
        player_id: The ID of the player.

    Returns:
        A pandas DataFrame containing the player's pitching statistics,
        or None if the player is not found.
    """
    try:
        player_id = int(player_id)  # Ensure player_id is an integer
        player_stats = pitching_stats[pitching_stats["player_id"] == player_id]
        if not player_stats.empty:
            return player_stats
        else:
          return None
    except (ValueError, KeyError):
        return None

# Example usage
player_id_to_lookup = 605141  # Example player ID (replace with desired ID)
player_stats_result = get_player_stats(player_id_to_lookup)

if player_stats_result is not None:
  print(player_stats_result)
else:
  print(f"No stats found for player ID: {player_id_to_lookup}")
#
# This is the Python code that makes this feedback form work.
# It's a Python class, with a method that runs when the user
# clicks the SUBMIT button.
#
# When the button is clicked, we send the contents of the
# text boxes to our Server Module. The Server Module records
# the feedback in the database, and sends an email to the
# app's owner (that's you!).
#
# To find the Server Module, look under "Server Code" on the
# left.
#


class HomeForm(HomeFormTemplate):
  def __init__(self, **properties):
    # Set Form properties and Data Bindings.
    self.init_components(**properties)

    # Any code you write here will run when the form opens.

  def submit_button_click(self, **event_args):
    # This method runs when the button is clicked.
    # First, we grab the contents of the text boxes:
    name = self.name_box.text
    email = self.email_box.text
    feedback = self.feedback_box.text

    # Now we call our Server Module to save our input
    # in the database and send you an email:
    anvil.server.call("add_feedback", name, email, feedback)
    # (Hint: Find ServerModule1 under "Server Code" on the
    # left. Click on the folder icon if you can't see it.)

    # Display something to the user so they know it worked:
    Notification("Feedback submitted!").show()
    self.clear_inputs()

  def clear_inputs(self):
    self.name_box.text = ""
    self.email_box.text = ""
    self.feedback_box.text = ""
